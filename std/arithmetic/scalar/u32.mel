
use core/arithmetic/scalar::StaticAddU32 as CoreStaticAddU32

/**
Add a static value to `u32`.

Every number passed through the stream get `value` added.

```
use std/arithmetic/scalar/u32::StaticAddU32

sequence Foo()
  input  in:  Stream<u32>
  output out: Stream<u32>
{
    StaticAddU32(value=5)

    // in is increased by 5 and send to out
    Self.in -> StaticAddU32.value,value -> Self.out
}
```
*/
sequence StaticAddU32(var value: u32 = 0)
  input  value: Stream<u32>
  output value: Stream<u32>
{
    CoreStaticAddU32(value=value)

    Self.value -> CoreStaticAddU32.value,value -> Self.value
}


use core/arithmetic/scalar::AddU32 as CoreAddU32

/**
Add values from two streams of `u32`.

Values passed through a & b are added and send in sum.

*/
sequence AddU32()
  input  a:   Stream<u32>
  input  b:   Stream<u32>
  output sum: Stream<u32>
{
    CoreAddU32()

    Self.a -> CoreAddU32.a
    Self.b -> CoreAddU32.b
    
    CoreAddU32.sum -> Self.sum
}


use core/arithmetic/scalar::StaticSubU32 as CoreStaticSubU32

/**
Substract a static value to `u32`.

Every number passed through the stream get `value` substracted.

*/
sequence StaticSubU32(var sub: u32 = 0)
  input  value: Stream<u32>
  output value: Stream<u32>
{
    CoreStaticSubU32(sub=sub)

    Self.value -> CoreStaticSubU32.value,value -> Self.value
}


use core/arithmetic/scalar::SubU32 as CoreSubU32

/**
Substract values from two streams of `u32`.

Every `a` number passed through the stream get `b` substracted.

*/
sequence SubU32()
  input  a:          Stream<u32>
  input  b:          Stream<u32>
  output difference: Stream<u32>
{
    CoreSubU32()

    Self.a -> CoreSubU32.a
    Self.b -> CoreSubU32.b
    
    CoreSubU32.difference -> Self.difference
}


use core/arithmetic/scalar::StaticMultU32 as CoreStaticMultU32

/**
Multiply `u32` by static value.

Every number passed through the stream is multiplied by `value`.

*/
sequence StaticMultU32(var factor: u32 = 0)
  input  value: Stream<u32>
  output value: Stream<u32>
{
    CoreStaticMultU32(factor=factor)

    Self.value -> CoreStaticMultU32.value,value -> Self.value
}


use core/arithmetic/scalar::MultU32 as CoreMultU32

/**
Multiply values from two streams of `u32`.

Every `a` number passed through the stream is multiplied by `b`.

*/
sequence MultU32()
  input  a:       Stream<u32>
  input  b:       Stream<u32>
  output product: Stream<u32>
{
    CoreMultU32()

    Self.a -> CoreMultU32.a
    Self.b -> CoreMultU32.b
    
    CoreMultU32.product -> Self.product
}


use core/arithmetic/scalar::StaticDivU32 as CoreStaticDivU32

/**
Divide a stream of `u32` by a static value.

Every number passed through the stream is divided by `value`.

*/
sequence StaticDivU32(var divisor: u32 = 0)
  input  value: Stream<u32>
  output value: Stream<u32>
{
    CoreStaticDivU32(divisor=divisor)

    Self.value -> CoreStaticDivU32.value,value -> Self.value
}


use core/arithmetic/scalar::DivU32 as CoreDivU32

/**
Divide values from two streams of `u32`.

Every `a` number passed through the stream is divided by `b`.

*/
sequence DivU32()
  input  a:        Stream<u32>
  input  b:        Stream<u32>
  output quotient: Stream<u32>
{
    CoreDivU32()

    Self.a -> CoreDivU32.a
    Self.b -> CoreDivU32.b
    
    CoreDivU32.quotient -> Self.quotient
}


use core/arithmetic/scalar::StaticRemU32 as CoreStaticRemU32

/**
Give the remainder of a stream of `u32` divided by a static value.

Every number passed through the stream is divided by `value` and the remainder is outputted.

*/
sequence StaticRemU32(var divisor: u32 = 0)
  input  value: Stream<u32>
  output value: Stream<u32>
{
    CoreStaticRemU32(divisor=divisor)

    Self.value -> CoreStaticRemU32.value,value -> Self.value
}


use core/arithmetic/scalar::RemU32 as CoreRemU32

/**
Give the remainder of the division from two streams of `u32`.

Every `a` number passed through the stream is divided by `b` and the remainder is outputted.

*/
sequence RemU32()
  input  a:         Stream<u32>
  input  b:         Stream<u32>
  output remainder: Stream<u32>
{
    CoreRemU32()

    Self.a -> CoreRemU32.a
    Self.b -> CoreRemU32.b
    
    CoreRemU32.remainder -> Self.remainder
}




use core/arithmetic/scalar::StaticPowU32 as CoreStaticPowU32

/**
Elevates `u32` to the power of a static value.

Every number passed through the stream get elevated to the power of `exponent`.
*/
sequence StaticPowU32(var exponent: u32 = 0)
  input  value: Stream<u32>
  output value: Stream<u32>
{
    CoreStaticPowU32(exponent=exponent)

    Self.value -> CoreStaticPowU32.value,value -> Self.value
}


use core/arithmetic/scalar::PowU32 as CorePowU32

/**
Elevates values from a stream of `u32` to the power of another one.

Values passed through `base` are elevated to the power of `exponent`.

*/
sequence PowU32()
  input  base:     Stream<u32>
  input  exponent: Stream<u32>
  output power:    Stream<u32>
{
    CorePowU32()

    Self.base -----> CorePowU32.base
    Self.exponent -> CorePowU32.exponent
    
    CorePowU32.power -> Self.power
}


