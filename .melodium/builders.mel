/*use std/flow::passBlock
use std/ops/vec/block::concat

treatment appendStepsIf(var list: Vec<string>, var contains: string, var commands: Vec<string>, var variables: Map)
  input commands: Stream<string>
  input variables: Block<Map>
  output commands: Stream<string>
  output variables: Block<Map>
{
    concat<string>()
}*/

use process/command::Command
use process/environment::Environment
use process/environment::mapEnvironment
use process/exec::Executor
use process/exec::spawn
use std/flow::emit
use std/flow::one
use std/flow::stream
use std/flow/vec::flatten
use std/ops/option/block::map
use std/ops/option/block::reduce
use std/text/convert/string::fromUtf8
use std/text/compose::rescale
use std/text/compose::trimEnd
use std/data::Map
use log/log::logInfos
use log/log::logErrors
use log/log::logError
use log/logger::Logger
use fs/file::read
use fs/filesystem::FileSystem

treatment stepFileResult[logger: Logger](var label: string, var environment_variables: Option<Map> = _, var commands: Vec<Command>, var file: string)
  input executor: Block<Executor>
  input filesystem: Block<FileSystem>
  input trigger: Block<void>
  output started: Block<void>
  output finished: Block<void>
  output failed: Block<void>
  output completed: Block<void>
  output data: Stream<byte>
{
    step[logger=logger](label=label, environment_variables=environment_variables, commands=commands)

    Self.executor -> step.executor
    Self.trigger --> step.trigger,started -> Self.started

    readWithLog[logger=logger](label=label, file=file)

    Self.filesystem -> readWithLog.filesystem
    step.completed --> readWithLog.trigger

    oneFailed: one<void>()
    step.failed --------> oneFailed.a,value -> Self.failed
    readWithLog.failed -> oneFailed.b

    oneFinished: one<void>()
    step.failed ----------> oneFinished.a,value -> Self.finished
    readWithLog.finished -> oneFinished.b

    readWithLog.completed -> Self.completed
    readWithLog.data ------> Self.data
}

treatment readWithLog[logger: Logger](var label: string, var file: string)
  input filesystem: Block<FileSystem>
  input trigger: Block<void>
  output started: Block<void>
  output finished: Block<void>
  output failed: Block<void>
  output completed: Block<void>
  output data: Stream<byte>
{
    emitFilename: emit<string>(value=file)
    read()

    Self.filesystem ---------------------------> read.filesystem
    Self.trigger -> emitFilename.trigger,emit -> read.path

    logErrs: logErrors[logger=logger](label=label)

    read.errors -> logErrs.messages

    read.reached ---> Self.started
    read.finished --> Self.finished
    read.failed ----> Self.failed
    read.completed -> Self.completed

    read.data ------> Self.data
}

treatment step[logger: Logger](var label: string, var environment_variables: Option<Map> = _, var commands: Vec<Command>)
  input executor: Block<Executor>
  input trigger: Block<void>
  output started: Block<void>
  output finished: Block<void>
  output failed: Block<void>
  output completed: Block<void>
{
    emitCommands: emit<Vec<Command>>(value=commands)
    streamCommands: stream<Vec<Command>>()
    flattenCommands: flatten<Command>()

    Self.trigger -> emitCommands.trigger,emit -> streamCommands.block,stream -> flattenCommands.vector

    emitEnvVars: emit<Option<Map>>(value=environment_variables)
    mapEnv: map<Map>()
    mapEnvironment(working_directory = _, clear_env = false)
    reduceEnv: reduce<Environment>()

    Self.trigger -> emitEnvVars.trigger,emit -> mapEnv.option,none -----------------------------------> reduceEnv.none
                                                mapEnv.value -> mapEnvironment.variables,environment -> reduceEnv.value

    spawn()

    Self.executor ---------> spawn.executor
    reduceEnv.option ------> spawn.environment
    flattenCommands.value -> spawn.commands

    logSpawnErr: logError[logger=logger](label=label)
    logSpawnErrsString: ioToString()
    logSpawnErrs: logErrors[logger=logger](label=label)
    logSpawnInfosString: ioToString()
    logSpawnInfos: logInfos[logger=logger](label=label)
    spawn.error --> logSpawnErr.message
    spawn.stderr -> logSpawnErrsString.stdio,lines -> logSpawnErrs.messages
    spawn.stdout -> logSpawnInfosString.stdio,lines -> logSpawnInfos.messages

    spawn.started ---> Self.started
    spawn.finished --> Self.finished
    spawn.failed ----> Self.failed
    spawn.completed -> Self.completed
}

treatment ioToString()
  input  stdio: Stream<byte>
  output lines: Stream<string>
{
    fromUtf8()
    rescale(delimiter="\n")
    trimEnd()

    Self.stdio -> fromUtf8.encoded,text -> rescale.unscaled,scaled -> trimEnd.text,trimmed -> Self.lines
}

