
use core/cast/scalar::U8ToI32 as CoreU8ToI32

/**
Convert stream of `u8` into `i32`.

This conversion is lossless, `u8` values can always fit into `i32` ones.
*/
sequence U8ToI32()
  input  value: Stream<u8>
  output value: Stream<i32>
{
    CoreU8ToI32()

    Self.value -> CoreU8ToI32.value,value -> Self.value
}



use core/cast/scalar::U16ToI32 as CoreU16ToI32

/**
Convert stream of `u16` into `i32`.

This conversion is lossless, `u16` values can always fit into `i32` ones.
*/
sequence U16ToI32()
  input  value: Stream<u16>
  output value: Stream<i32>
{
    CoreU16ToI32()

    Self.value -> CoreU16ToI32.value,value -> Self.value
}



use core/cast/scalar::I8ToI32 as CoreI8ToI32

/**
Convert stream of `i8` into `i32`.

This conversion is lossless, `i8` values can always fit into `i32` ones.
*/
sequence I8ToI32()
  input  value: Stream<i8>
  output value: Stream<i32>
{
    CoreI8ToI32()

    Self.value -> CoreI8ToI32.value,value -> Self.value
}



use core/cast/scalar::I16ToI32 as CoreI16ToI32

/**
Convert stream of `i16` into `i32`.

This conversion is lossless, `i16` values can always fit into `i32` ones.
*/
sequence I16ToI32()
  input  value: Stream<i16>
  output value: Stream<i32>
{
    CoreI16ToI32()

    Self.value -> CoreI16ToI32.value,value -> Self.value
}



use core/cast/scalar::CastScalarU32ToI32 as CoreCastScalarU32ToI32 

/**
Convert stream of `u32` into `i32`.

As this conversion might be lossy (every possible `u32` value cannot fit into `i32`),
`truncate` allows value to be truncated to fit into a `i32`, and `or_default` set the
value that is assigned when a `u32` is out of range for `i32` and truncation not allowed.
*/
sequence U32ToI32(var truncate: bool = true, var or_default: i32 = 0)
  input  value: Stream<u32>
  output value: Stream<i32>
{
    CoreCastScalarU32ToI32()

    Self.value -> CoreCastScalarU32ToI32.value,value -> Self.value
}



use core/cast/scalar::CastScalarU64ToI32 as CoreCastScalarU64ToI32 

/**
Convert stream of `u64` into `i32`.

As this conversion might be lossy (every possible `u64` value cannot fit into `i32`),
`truncate` allows value to be truncated to fit into a `i32`, and `or_default` set the
value that is assigned when a `u64` is out of range for `i32` and truncation not allowed.
*/
sequence U64ToI32(var truncate: bool = true, var or_default: i32 = 0)
  input  value: Stream<u64>
  output value: Stream<i32>
{
    CoreCastScalarU64ToI32()

    Self.value -> CoreCastScalarU64ToI32.value,value -> Self.value
}



use core/cast/scalar::CastScalarU128ToI32 as CoreCastScalarU128ToI32 

/**
Convert stream of `u128` into `i32`.

As this conversion might be lossy (every possible `u128` value cannot fit into `i32`),
`truncate` allows value to be truncated to fit into a `i32`, and `or_default` set the
value that is assigned when a `u128` is out of range for `i32` and truncation not allowed.
*/
sequence U128ToI32(var truncate: bool = true, var or_default: i32 = 0)
  input  value: Stream<u128>
  output value: Stream<i32>
{
    CoreCastScalarU128ToI32()

    Self.value -> CoreCastScalarU128ToI32.value,value -> Self.value
}



use core/cast/scalar::CastScalarI64ToI32 as CoreCastScalarI64ToI32 

/**
Convert stream of `i64` into `i32`.

As this conversion might be lossy (every possible `i64` value cannot fit into `i32`),
`truncate` allows value to be truncated to fit into a `i32`, and `or_default` set the
value that is assigned when a `i64` is out of range for `i32` and truncation not allowed.
*/
sequence I64ToI32(var truncate: bool = true, var or_default: i32 = 0)
  input  value: Stream<i64>
  output value: Stream<i32>
{
    CoreCastScalarI64ToI32()

    Self.value -> CoreCastScalarI64ToI32.value,value -> Self.value
}



use core/cast/scalar::CastScalarI128ToI32 as CoreCastScalarI128ToI32 

/**
Convert stream of `i128` into `i32`.

As this conversion might be lossy (every possible `i128` value cannot fit into `i32`),
`truncate` allows value to be truncated to fit into a `i32`, and `or_default` set the
value that is assigned when a `i128` is out of range for `i32` and truncation not allowed.
*/
sequence I128ToI32(var truncate: bool = true, var or_default: i32 = 0)
  input  value: Stream<i128>
  output value: Stream<i32>
{
    CoreCastScalarI128ToI32()

    Self.value -> CoreCastScalarI128ToI32.value,value -> Self.value
}



use core/conversion/scalar::ScalarF32ToI32 as CoreScalarF32ToI32 

/**
Convert stream of `f32` into `i32`.

Every `f32` is truncated to fit into the `i32`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f32` is a positive infinity,
- `neg_infinity` is used when `f32` is a negative infinity,
- `nan` is used when `f32` is not a number.
*/
sequence F32ToI32(var pos_infinity: i32 = 2147483647, var neg_infinity: i32 = -2147483648, var nan: i32 = 0)
  input  value: Stream<f32>
  output value: Stream<i32>
{
    CoreScalarF32ToI32(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)

    Self.value -> CoreScalarF32ToI32.value,value -> Self.value
}



use core/conversion/scalar::ScalarF64ToI32 as CoreScalarF64ToI32 

/**
Convert stream of `f64` into `i32`.

Every `f64` is truncated to fit into the `i32`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f64` is a positive infinity,
- `neg_infinity` is used when `f64` is a negative infinity,
- `nan` is used when `f64` is not a number.
*/
sequence F64ToI32(var pos_infinity: i32 = 2147483647, var neg_infinity: i32 = -2147483648, var nan: i32 = 0)
  input  value: Stream<f64>
  output value: Stream<i32>
{
    CoreScalarF64ToI32(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)

    Self.value -> CoreScalarF64ToI32.value,value -> Self.value
}


