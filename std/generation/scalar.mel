
use core/generation::ScalarU8Generator
use core/generation::GenerateScalarU8

/**
Generates streams of `u8`.

Each stream generated contains `length` times `value`.
`tracks` set the number of tracks that will be generated, each one with its own stream.
*/
sequence GenerateU8(const tracks: u64 = 1, const length: u64 = 1024, const value: u8)
  model generator: ScalarU8Generator(tracks=tracks, length=length, value=value)
  output data: Stream<u8>
{
    GenerateScalarU8[generator=generator]()

    GenerateScalarU8.data -> Self.data
}



use core/generation::ScalarU16Generator
use core/generation::GenerateScalarU16

/**
Generates streams of `u16`.

Each stream generated contains `length` times `value`.
`tracks` set the number of tracks that will be generated, each one with its own stream.
*/
sequence GenerateU16(const tracks: u64 = 1, const length: u64 = 1024, const value: u16)
  model generator: ScalarU16Generator(tracks=tracks, length=length, value=value)
  output data: Stream<u16>
{
    GenerateScalarU16[generator=generator]()

    GenerateScalarU16.data -> Self.data
}



use core/generation::ScalarU32Generator
use core/generation::GenerateScalarU32

/**
Generates streams of `u32`.

Each stream generated contains `length` times `value`.
`tracks` set the number of tracks that will be generated, each one with its own stream.
*/
sequence GenerateU32(const tracks: u64 = 1, const length: u64 = 1024, const value: u32)
  model generator: ScalarU32Generator(tracks=tracks, length=length, value=value)
  output data: Stream<u32>
{
    GenerateScalarU32[generator=generator]()

    GenerateScalarU32.data -> Self.data
}



use core/generation::ScalarU64Generator
use core/generation::GenerateScalarU64

/**
Generates streams of `u64`.

Each stream generated contains `length` times `value`.
`tracks` set the number of tracks that will be generated, each one with its own stream.
*/
sequence GenerateU64(const tracks: u64 = 1, const length: u64 = 1024, const value: u64)
  model generator: ScalarU64Generator(tracks=tracks, length=length, value=value)
  output data: Stream<u64>
{
    GenerateScalarU64[generator=generator]()

    GenerateScalarU64.data -> Self.data
}



use core/generation::ScalarU128Generator
use core/generation::GenerateScalarU128

/**
Generates streams of `u128`.

Each stream generated contains `length` times `value`.
`tracks` set the number of tracks that will be generated, each one with its own stream.
*/
sequence GenerateU128(const tracks: u64 = 1, const length: u64 = 1024, const value: u128)
  model generator: ScalarU128Generator(tracks=tracks, length=length, value=value)
  output data: Stream<u128>
{
    GenerateScalarU128[generator=generator]()

    GenerateScalarU128.data -> Self.data
}



use core/generation::ScalarI8Generator
use core/generation::GenerateScalarI8

/**
Generates streams of `i8`.

Each stream generated contains `length` times `value`.
`tracks` set the number of tracks that will be generated, each one with its own stream.
*/
sequence GenerateI8(const tracks: u64 = 1, const length: u64 = 1024, const value: i8)
  model generator: ScalarI8Generator(tracks=tracks, length=length, value=value)
  output data: Stream<i8>
{
    GenerateScalarI8[generator=generator]()

    GenerateScalarI8.data -> Self.data
}



use core/generation::ScalarI16Generator
use core/generation::GenerateScalarI16

/**
Generates streams of `i16`.

Each stream generated contains `length` times `value`.
`tracks` set the number of tracks that will be generated, each one with its own stream.
*/
sequence GenerateI16(const tracks: u64 = 1, const length: u64 = 1024, const value: i16)
  model generator: ScalarI16Generator(tracks=tracks, length=length, value=value)
  output data: Stream<i16>
{
    GenerateScalarI16[generator=generator]()

    GenerateScalarI16.data -> Self.data
}



use core/generation::ScalarI32Generator
use core/generation::GenerateScalarI32

/**
Generates streams of `i32`.

Each stream generated contains `length` times `value`.
`tracks` set the number of tracks that will be generated, each one with its own stream.
*/
sequence GenerateI32(const tracks: u64 = 1, const length: u64 = 1024, const value: i32)
  model generator: ScalarI32Generator(tracks=tracks, length=length, value=value)
  output data: Stream<i32>
{
    GenerateScalarI32[generator=generator]()

    GenerateScalarI32.data -> Self.data
}



use core/generation::ScalarI64Generator
use core/generation::GenerateScalarI64

/**
Generates streams of `i64`.

Each stream generated contains `length` times `value`.
`tracks` set the number of tracks that will be generated, each one with its own stream.
*/
sequence GenerateI64(const tracks: u64 = 1, const length: u64 = 1024, const value: i64)
  model generator: ScalarI64Generator(tracks=tracks, length=length, value=value)
  output data: Stream<i64>
{
    GenerateScalarI64[generator=generator]()

    GenerateScalarI64.data -> Self.data
}



use core/generation::ScalarI128Generator
use core/generation::GenerateScalarI128

/**
Generates streams of `i128`.

Each stream generated contains `length` times `value`.
`tracks` set the number of tracks that will be generated, each one with its own stream.
*/
sequence GenerateI128(const tracks: u64 = 1, const length: u64 = 1024, const value: i128)
  model generator: ScalarI128Generator(tracks=tracks, length=length, value=value)
  output data: Stream<i128>
{
    GenerateScalarI128[generator=generator]()

    GenerateScalarI128.data -> Self.data
}



use core/generation::ScalarF32Generator
use core/generation::GenerateScalarF32

/**
Generates streams of `f32`.

Each stream generated contains `length` times `value`.
`tracks` set the number of tracks that will be generated, each one with its own stream.
*/
sequence GenerateF32(const tracks: u64 = 1, const length: u64 = 1024, const value: f32)
  model generator: ScalarF32Generator(tracks=tracks, length=length, value=value)
  output data: Stream<f32>
{
    GenerateScalarF32[generator=generator]()

    GenerateScalarF32.data -> Self.data
}



use core/generation::ScalarF64Generator
use core/generation::GenerateScalarF64

/**
Generates streams of `f64`.

Each stream generated contains `length` times `value`.
`tracks` set the number of tracks that will be generated, each one with its own stream.
*/
sequence GenerateF64(const tracks: u64 = 1, const length: u64 = 1024, const value: f64)
  model generator: ScalarF64Generator(tracks=tracks, length=length, value=value)
  output data: Stream<f64>
{
    GenerateScalarF64[generator=generator]()

    GenerateScalarF64.data -> Self.data
}



use core/generation::ScalarBoolGenerator
use core/generation::GenerateScalarBool

/**
Generates streams of `bool`.

Each stream generated contains `length` times `value`.
`tracks` set the number of tracks that will be generated, each one with its own stream.
*/
sequence GenerateBool(const tracks: u64 = 1, const length: u64 = 1024, const value: bool)
  model generator: ScalarBoolGenerator(tracks=tracks, length=length, value=value)
  output data: Stream<bool>
{
    GenerateScalarBool[generator=generator]()

    GenerateScalarBool.data -> Self.data
}



use core/generation::ScalarByteGenerator
use core/generation::GenerateScalarByte

/**
Generates streams of `byte`.

Each stream generated contains `length` times `value`.
`tracks` set the number of tracks that will be generated, each one with its own stream.
*/
sequence GenerateByte(const tracks: u64 = 1, const length: u64 = 1024, const value: byte)
  model generator: ScalarByteGenerator(tracks=tracks, length=length, value=value)
  output data: Stream<byte>
{
    GenerateScalarByte[generator=generator]()

    GenerateScalarByte.data -> Self.data
}



use core/generation::ScalarCharGenerator
use core/generation::GenerateScalarChar

/**
Generates streams of `char`.

Each stream generated contains `length` times `value`.
`tracks` set the number of tracks that will be generated, each one with its own stream.
*/
sequence GenerateChar(const tracks: u64 = 1, const length: u64 = 1024, const value: char)
  model generator: ScalarCharGenerator(tracks=tracks, length=length, value=value)
  output data: Stream<char>
{
    GenerateScalarChar[generator=generator]()

    GenerateScalarChar.data -> Self.data
}



use core/generation::ScalarStringGenerator
use core/generation::GenerateScalarString

/**
Generates streams of `string`.

Each stream generated contains `length` times `value`.
`tracks` set the number of tracks that will be generated, each one with its own stream.
*/
sequence GenerateString(const tracks: u64 = 1, const length: u64 = 1024, const value: string)
  model generator: ScalarStringGenerator(tracks=tracks, length=length, value=value)
  output data: Stream<string>
{
    GenerateScalarString[generator=generator]()

    GenerateScalarString.data -> Self.data
}


