use core/conversion/scalar::BoolToVoid

/**
Turns `bool` stream into `void` one.

Send one `iter` per input `value` received.
*/
sequence ToVoid()
  input value: Stream<bool>
  output iter: Stream<void>
{
    BoolToVoid()

    Self.value -> BoolToVoid.value,iter -> Self.iter
}

use core/conversion/scalar::BoolToByte

/**
Convert stream of `bool` into `Vec<byte>`.

`bool` gets converted into `Vec<byte>`, each vector contains the bytes of the former scalar `bool` it represents.
*/
sequence ToByte()
  input  value: Stream<bool>
  output data:  Stream<Vec<byte>>
{
    BoolToByte()

    Self.value -> BoolToByte.value,data -> Self.data
}

use core/conversion/scalar::BoolFromByte

/**
Convert stream of `Vec<byte>` into `bool`.

Each received `byte` vector try to be converted into `bool`, and if valid is sent as `value`. If the incoming vector 
is not valid for representing a `bool` (i.e. not right size or invalid coding) it is refused and sent through `reject`.
*/
sequence FromByte()
  input  data:   Stream<Vec<byte>>
  output value:  Stream<bool>
  output reject: Stream<Vec<byte>>
{
    BoolFromByte()

    Self.data -> BoolFromByte.data,value -> Self.value
                 BoolFromByte.reject -----> Self.reject
}

use core/conversion/scalar::BoolToString

/**
Convert stream of `bool` into `string`.

`bool` gets converted into `string`, and the resulting strings are send through stream in continuity.
*/
sequence ToString()
  input  value: Stream<bool>
  output value: Stream<string>
{
    BoolToString()

    Self.value -> BoolToString.value,value -> Self.value
}

