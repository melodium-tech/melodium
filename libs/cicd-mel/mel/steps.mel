use process/command::Command
use process/environment::Environment
use process/environment::mapEnvironment
use process/exec::Executor
use process/exec::spawn
use std/flow::check
use std/flow::emit
use std/flow::one
use std/flow::stream
use std/flow::waitBlock
use std/flow::cut
use std/flow/vec::flatten
use std/ops/option/block::map
use std/ops/option/block::reduce
use std/data/string_map::StringMap
use std/data::|map
use std/data::|entry
use log/log::logInfos
use log/log::logErrors
use log/log::logError
use log/logger::Log
use log/logger::Logger
use log/logger::trackLogs
use log/logger::logs
use log/logger::injectStreamLog
use fs/file::read
use fs/filesystem::FileSystem
use work/distant::DistantEngine
use work/distant::distant
use work/resources/arch::Arch
use work/resources::Container
use work/resources::Volume
use work/resources::getExecutor

treatment step[logger: Logger](var label: string, var environment_variables: Option<StringMap> = _, var commands: Vec<Command>)
  input executor: Block<Executor>
  input trigger: Block<void>
  output started: Block<void>
  output finished: Block<void>
  output failed: Block<void>
  output completed: Block<void>
{
    emitCommands: emit<Vec<Command>>(value=commands)
    streamCommands: stream<Vec<Command>>()
    flattenCommands: flatten<Command>()

    Self.trigger -> emitCommands.trigger,emit -> streamCommands.block,stream -> flattenCommands.vector

    emitEnvVars: emit<Option<StringMap>>(value=environment_variables)
    mapEnv: map<StringMap>()
    mapEnvironment(working_directory = _, clear_env = false)
    reduceEnv: reduce<Environment>()

    Self.trigger -> emitEnvVars.trigger,emit -> mapEnv.option,none -----------------------------------> reduceEnv.none
                                                mapEnv.value -> mapEnvironment.variables,environment -> reduceEnv.value

    spawn()

    Self.executor ---------> spawn.executor
    reduceEnv.option ------> spawn.environment
    flattenCommands.value -> spawn.commands

    logSpawnErr: logError[logger=logger](label=label)
    logSpawnErrsString: ioToString()
    logSpawnErrs: logErrors[logger=logger](label=label)
    logSpawnInfosString: ioToString()
    logSpawnInfos: logInfos[logger=logger](label=label)
    spawn.error --> logSpawnErr.message
    spawn.stderr -> logSpawnErrsString.stdio,lines -> logSpawnErrs.messages
    spawn.stdout -> logSpawnInfosString.stdio,lines -> logSpawnInfos.messages

    waitAllMessages: waitBlock<void>()
    waitSpawnFinishedAndAllMessages: waitBlock<void>()

    logSpawnErrs.ended --> waitAllMessages.a
    logSpawnInfos.ended -> waitAllMessages.b,awaited -> waitSpawnFinishedAndAllMessages.a
    spawn.finished -----------------------------------> waitSpawnFinishedAndAllMessages.b

    spawn.started ----------------------------> Self.started
    waitSpawnFinishedAndAllMessages.awaited --> Self.finished
    spawn.failed -----------------------------> Self.failed
    spawn.completed --------------------------> Self.completed
}