use core/arithmetic/scalar::StaticAddI128

/**
Add a static value to `i128`.

Every number passed through the stream get `add` added.
*/
sequence StaticAdd(var add: i128 = 0)
  input  value: Stream<i128>
  output value: Stream<i128>
{
    StaticAddI128(add=add)

    Self.value -> StaticAddI128.value,value -> Self.value
}

use core/arithmetic/scalar::AddI128

/**
Add values from two streams of `i128`.

Values passed through a & b are added and send in sum.

*/
sequence Add()
  input  a:   Stream<i128>
  input  b:   Stream<i128>
  output sum: Stream<i128>
{
    AddI128()

    Self.a -> AddI128.a
    Self.b -> AddI128.b
    
    AddI128.sum -> Self.sum
}

use core/arithmetic/scalar::StaticSubI128 

/**
Substract a static value to `i128`.

Every number passed through the stream get `sub` substracted.

*/
sequence StaticSub(var sub: i128 = 0)
  input  value: Stream<i128>
  output value: Stream<i128>
{
    StaticSubI128(sub=sub)

    Self.value -> StaticSubI128.value,value -> Self.value
}


use core/arithmetic/scalar::SubI128 

/**
Substract values from two streams of `i128`.

Every `a` number passed through the stream get `b` substracted.

*/
sequence Sub()
  input  a:          Stream<i128>
  input  b:          Stream<i128>
  output difference: Stream<i128>
{
    SubI128()

    Self.a -> SubI128.a
    Self.b -> SubI128.b
    
    SubI128.difference -> Self.difference
}


use core/arithmetic/scalar::StaticMultI128 

/**
Multiply `i128` by static value.

Every number passed through the stream is multiplied by `factor`.

*/
sequence StaticMult(var factor: i128 = 0)
  input  value: Stream<i128>
  output value: Stream<i128>
{
    StaticMultI128(factor=factor)

    Self.value -> StaticMultI128.value,value -> Self.value
}


use core/arithmetic/scalar::MultI128 

/**
Multiply values from two streams of `i128`.

Every `a` number passed through the stream is multiplied by `b`.

*/
sequence Mult()
  input  a:       Stream<i128>
  input  b:       Stream<i128>
  output product: Stream<i128>
{
    MultI128()

    Self.a -> MultI128.a
    Self.b -> MultI128.b
    
    MultI128.product -> Self.product
}


use core/arithmetic/scalar::StaticDivI128 

/**
Divide a stream of `i128` by a static value.

Every number passed through the stream is divided by `divisor`.

*/
sequence StaticDiv(var divisor: i128 = 0)
  input  value: Stream<i128>
  output value: Stream<i128>
{
    StaticDivI128(divisor=divisor)

    Self.value -> StaticDivI128.value,value -> Self.value
}


use core/arithmetic/scalar::DivI128 

/**
Divide values from two streams of `i128`.

Every `a` number passed through the stream is divided by `b`.

*/
sequence Div()
  input  a:        Stream<i128>
  input  b:        Stream<i128>
  output quotient: Stream<i128>
{
    DivI128()

    Self.a -> DivI128.a
    Self.b -> DivI128.b
    
    DivI128.quotient -> Self.quotient
}


use core/arithmetic/scalar::StaticRemI128 

/**
Give the remainder of a stream of `i128` divided by a static value.

Every number passed through the stream is divided by `divisor` and the remainder is outputted.

*/
sequence StaticRem(var divisor: i128 = 0)
  input  value: Stream<i128>
  output value: Stream<i128>
{
    StaticRemI128(divisor=divisor)

    Self.value -> StaticRemI128.value,value -> Self.value
}


use core/arithmetic/scalar::RemI128 

/**
Give the remainder of the division from two streams of `i128`.

Every `a` number passed through the stream is divided by `b` and the remainder is outputted.

*/
sequence Rem()
  input  a:         Stream<i128>
  input  b:         Stream<i128>
  output remainder: Stream<i128>
{
    RemI128()

    Self.a -> RemI128.a
    Self.b -> RemI128.b
    
    RemI128.remainder -> Self.remainder
}




use core/arithmetic/scalar::StaticPowI128 

/**
Elevates `i128` to the power of a static value.

Every number passed through the stream get elevated to the power of `exponent`.
*/
sequence StaticPow(var exponent: i128 = 0)
  input  value: Stream<i128>
  output value: Stream<i128>
{
    StaticPowI128(exponent=exponent)

    Self.value -> StaticPowI128.value,value -> Self.value
}


use core/arithmetic/scalar::PowI128 

/**
Elevates values from a stream of `i128` to the power of another one.

Values passed through `base` are elevated to the power of `exponent`.

*/
sequence Pow()
  input  base:     Stream<i128>
  input  exponent: Stream<i128>
  output power:    Stream<i128>
{
    PowI128()

    Self.base -----> PowI128.base
    Self.exponent -> PowI128.exponent
    
    PowI128.power -> Self.power
}

use core/arithmetic/scalar::AbsI128

/**
Get the absolute values from a stream of `i128`.

*/
sequence Abs()
  input  value: Stream<i128>
  output value: Stream<i128>
{
    AbsI128()

    Self.value -> AbsI128.value,value -> Self.value
}
