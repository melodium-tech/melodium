use core/conversion/scalar::U128ToVoid

/**
Turns `u128` stream into `void` one.

Send one `iter` per input `value` received.
*/
sequence ToVoid()
  input value: Stream<u128>
  output iter: Stream<void>
{
    U128ToVoid()

    Self.value -> U128ToVoid.value,iter -> Self.iter
}

use core/conversion/scalar::U128ToByte

/**
Convert stream of `u128` into `Vec<byte>`.

`u128` gets converted into `Vec<byte>`, each vector contains the bytes of the former scalar `u128` it represents.
*/
sequence ToByte()
  input  value: Stream<u128>
  output data:  Stream<Vec<byte>>
{
    U128ToByte()

    Self.value -> U128ToByte.value,data -> Self.data
}

use core/conversion/scalar::U128FromByte

/**
Convert stream of `Vec<byte>` into `u128`.

Each received `byte` vector try to be converted into `u128`, and if valid is sent as `value`. If the incoming vector 
is not valid for representing a `u128` (i.e. not right size or invalid coding) it is refused and sent through `reject`.
*/
sequence FromByte()
  input  data:   Stream<Vec<byte>>
  output value:  Stream<u128>
  output reject: Stream<Vec<byte>>
{
    U128FromByte()

    Self.data -> U128FromByte.data,value -> Self.value
                 U128FromByte.reject -----> Self.reject
}

use core/conversion/scalar::U128ToString

/**
Convert stream of `u128` into `string`.

`u128` gets converted into `string`, and the resulting strings are send through stream in continuity.
*/
sequence ToString()
  input  value: Stream<u128>
  output value: Stream<string>
{
    U128ToString()

    Self.value -> U128ToString.value,value -> Self.value
}

use core/cast/scalar::U128ToF32

/**
Convert stream of `u128` into `f32`.

This conversion is lossless, `u128` values can all fit into `f32`.
*/
sequence ToF32()
  input  value: Stream<u128>
  output value: Stream<f32>
{
    U128ToF32()

    Self.value -> U128ToF32.value,value -> Self.value
}


use core/cast/scalar::U128ToF64

/**
Convert stream of `u128` into `f64`.

This conversion is lossless, `u128` values can all fit into `f64`.
*/
sequence ToF64()
  input  value: Stream<u128>
  output value: Stream<f64>
{
    U128ToF64()

    Self.value -> U128ToF64.value,value -> Self.value
}


use core/cast/scalar::CastScalarU128ToU8

/**
Convert stream of `u128` into `u8`.

As this conversion might be lossy (every possible `u128` value cannot fit into `u8`),
`truncate` allows value to be truncated to fit into a `u8`, and `or_default` set the
value that is assigned when a `u128` is out of range for `u8` and truncation not allowed.

Truncation happens on the binary level, thus: `10010110` (150 if unsigned, -106 if [signed](https://en.wikipedia.org/wiki/Signed_number_representations)) → `0110` (6).
*/
sequence ToU8(var truncate: bool = true, var or_default: u8 = 0)
  input  value: Stream<u128>
  output value: Stream<u8>
{
    CastScalarU128ToU8(truncate=truncate, or_default=or_default)

    Self.value -> CastScalarU128ToU8.value,value -> Self.value
}


use core/cast/scalar::CastScalarU128ToU16

/**
Convert stream of `u128` into `u16`.

As this conversion might be lossy (every possible `u128` value cannot fit into `u16`),
`truncate` allows value to be truncated to fit into a `u16`, and `or_default` set the
value that is assigned when a `u128` is out of range for `u16` and truncation not allowed.

Truncation happens on the binary level, thus: `10010110` (150 if unsigned, -106 if [signed](https://en.wikipedia.org/wiki/Signed_number_representations)) → `0110` (6).
*/
sequence ToU16(var truncate: bool = true, var or_default: u16 = 0)
  input  value: Stream<u128>
  output value: Stream<u16>
{
    CastScalarU128ToU16(truncate=truncate, or_default=or_default)

    Self.value -> CastScalarU128ToU16.value,value -> Self.value
}


use core/cast/scalar::CastScalarU128ToU32

/**
Convert stream of `u128` into `u32`.

As this conversion might be lossy (every possible `u128` value cannot fit into `u32`),
`truncate` allows value to be truncated to fit into a `u32`, and `or_default` set the
value that is assigned when a `u128` is out of range for `u32` and truncation not allowed.

Truncation happens on the binary level, thus: `10010110` (150 if unsigned, -106 if [signed](https://en.wikipedia.org/wiki/Signed_number_representations)) → `0110` (6).
*/
sequence ToU32(var truncate: bool = true, var or_default: u32 = 0)
  input  value: Stream<u128>
  output value: Stream<u32>
{
    CastScalarU128ToU32(truncate=truncate, or_default=or_default)

    Self.value -> CastScalarU128ToU32.value,value -> Self.value
}


use core/cast/scalar::CastScalarU128ToU64

/**
Convert stream of `u128` into `u64`.

As this conversion might be lossy (every possible `u128` value cannot fit into `u64`),
`truncate` allows value to be truncated to fit into a `u64`, and `or_default` set the
value that is assigned when a `u128` is out of range for `u64` and truncation not allowed.

Truncation happens on the binary level, thus: `10010110` (150 if unsigned, -106 if [signed](https://en.wikipedia.org/wiki/Signed_number_representations)) → `0110` (6).
*/
sequence ToU64(var truncate: bool = true, var or_default: u64 = 0)
  input  value: Stream<u128>
  output value: Stream<u64>
{
    CastScalarU128ToU64(truncate=truncate, or_default=or_default)

    Self.value -> CastScalarU128ToU64.value,value -> Self.value
}


use core/cast/scalar::CastScalarU128ToI8

/**
Convert stream of `u128` into `i8`.

As this conversion might be lossy (every possible `u128` value cannot fit into `i8`),
`truncate` allows value to be truncated to fit into a `i8`, and `or_default` set the
value that is assigned when a `u128` is out of range for `i8` and truncation not allowed.

Truncation happens on the binary level, thus: `10010110` (150 if unsigned, -106 if [signed](https://en.wikipedia.org/wiki/Signed_number_representations)) → `0110` (6).
*/
sequence ToI8(var truncate: bool = true, var or_default: i8 = 0)
  input  value: Stream<u128>
  output value: Stream<i8>
{
    CastScalarU128ToI8(truncate=truncate, or_default=or_default)

    Self.value -> CastScalarU128ToI8.value,value -> Self.value
}


use core/cast/scalar::CastScalarU128ToI16

/**
Convert stream of `u128` into `i16`.

As this conversion might be lossy (every possible `u128` value cannot fit into `i16`),
`truncate` allows value to be truncated to fit into a `i16`, and `or_default` set the
value that is assigned when a `u128` is out of range for `i16` and truncation not allowed.

Truncation happens on the binary level, thus: `10010110` (150 if unsigned, -106 if [signed](https://en.wikipedia.org/wiki/Signed_number_representations)) → `0110` (6).
*/
sequence ToI16(var truncate: bool = true, var or_default: i16 = 0)
  input  value: Stream<u128>
  output value: Stream<i16>
{
    CastScalarU128ToI16(truncate=truncate, or_default=or_default)

    Self.value -> CastScalarU128ToI16.value,value -> Self.value
}


use core/cast/scalar::CastScalarU128ToI32

/**
Convert stream of `u128` into `i32`.

As this conversion might be lossy (every possible `u128` value cannot fit into `i32`),
`truncate` allows value to be truncated to fit into a `i32`, and `or_default` set the
value that is assigned when a `u128` is out of range for `i32` and truncation not allowed.

Truncation happens on the binary level, thus: `10010110` (150 if unsigned, -106 if [signed](https://en.wikipedia.org/wiki/Signed_number_representations)) → `0110` (6).
*/
sequence ToI32(var truncate: bool = true, var or_default: i32 = 0)
  input  value: Stream<u128>
  output value: Stream<i32>
{
    CastScalarU128ToI32(truncate=truncate, or_default=or_default)

    Self.value -> CastScalarU128ToI32.value,value -> Self.value
}


use core/cast/scalar::CastScalarU128ToI64

/**
Convert stream of `u128` into `i64`.

As this conversion might be lossy (every possible `u128` value cannot fit into `i64`),
`truncate` allows value to be truncated to fit into a `i64`, and `or_default` set the
value that is assigned when a `u128` is out of range for `i64` and truncation not allowed.

Truncation happens on the binary level, thus: `10010110` (150 if unsigned, -106 if [signed](https://en.wikipedia.org/wiki/Signed_number_representations)) → `0110` (6).
*/
sequence ToI64(var truncate: bool = true, var or_default: i64 = 0)
  input  value: Stream<u128>
  output value: Stream<i64>
{
    CastScalarU128ToI64(truncate=truncate, or_default=or_default)

    Self.value -> CastScalarU128ToI64.value,value -> Self.value
}


use core/cast/scalar::CastScalarU128ToI128

/**
Convert stream of `u128` into `i128`.

As this conversion might be lossy (every possible `u128` value cannot fit into `i128`),
`truncate` allows value to be truncated to fit into a `i128`, and `or_default` set the
value that is assigned when a `u128` is out of range for `i128` and truncation not allowed.

Truncation happens on the binary level, thus: `10010110` (150 if unsigned, -106 if [signed](https://en.wikipedia.org/wiki/Signed_number_representations)) → `0110` (6).
*/
sequence ToI128(var truncate: bool = true, var or_default: i128 = 0)
  input  value: Stream<u128>
  output value: Stream<i128>
{
    CastScalarU128ToI128(truncate=truncate, or_default=or_default)

    Self.value -> CastScalarU128ToI128.value,value -> Self.value
}


