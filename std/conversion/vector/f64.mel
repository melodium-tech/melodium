use std/flow/f64::Linearize
use std/flow/f64::Organize

use core/conversion/vector::F64ToVoid

/**
Convert stream of `Vec<f64>` into `Vec<void>` one.

This conversion is useful to extract pattern from a stream of vectors and work on it.

*/
sequence ToVoid()
  input  vector:  Stream<Vec<f64>>
  output pattern: Stream<Vec<void>>
{
    F64ToVoid()

    Self.vector -> F64ToVoid.vector,pattern -> Self.pattern
}

use std/conversion/scalar/f64::ToByte as ScalToByte

/**
Convert stream of `Vec<f64>` into `Vec<byte>` one.

`Vec<f64>` gets converted into `Vec<byte>`, and the resulting vectors are send through stream in continuity.
*/
sequence ToByte()
  input  value: Stream<Vec<f64>>
  output data:  Stream<Vec<byte>>
{
    ToVoid()
    Linearize()
    ScalToByte()
    Organize()

    Self.value -> Linearize.vector,value -> ScalToByte.value,data -> Organize.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern ---------------------------> Organize.pattern
}

use std/conversion/scalar/f64::ToString as ScalToString

/**
Convert stream of `Vec<f64>` into `Vec<string>` one.

`Vec<f64>` gets converted into `Vec<string>`, and the resulting vectors are send through stream in continuity.
*/
sequence ToString()
  input  value: Stream<Vec<f64>>
  output value: Stream<Vec<string>>
{
    ToVoid()
    Linearize()
    ScalToString()
    Organize()

    Self.value -> Linearize.vector,value -> ScalToString.value,value -> Organize.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern ------------------------------> Organize.pattern
}

use std/conversion/scalar/f64::ToU8 as ScalToU8

/**
Convert stream of `Vec<f64>` into `Vec<u8>` one.

`Vec<f64>` gets converted into `Vec<u8>`, and the resulting vectors are send through stream in continuity.

Every `f64` is truncated to fit into the `u8`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f64` is a positive infinity,
- `neg_infinity` is used when `f64` is a negative infinity,
- `nan` is used when `f64` is not a number.
*/
sequence ToU8(var pos_infinity: u8 = 255, var neg_infinity: u8 = 0, var nan: u8 = 0)
  input  value: Stream<Vec<f64>>
  output value: Stream<Vec<u8>>
{
    ToVoid()
    Linearize()
    ScalToU8(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)
    Organize()

    Self.value -> Linearize.vector,value -> ScalToU8.value,value -> Organize.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern -----------------------------> Organize.pattern
}

use std/conversion/scalar/f64::ToU16 as ScalToU16

/**
Convert stream of `Vec<f64>` into `Vec<u16>` one.

`Vec<f64>` gets converted into `Vec<u16>`, and the resulting vectors are send through stream in continuity.

Every `f64` is truncated to fit into the `u16`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f64` is a positive infinity,
- `neg_infinity` is used when `f64` is a negative infinity,
- `nan` is used when `f64` is not a number.
*/
sequence ToU16(var pos_infinity: u16 = 65535, var neg_infinity: u16 = 0, var nan: u16 = 0)
  input  value: Stream<Vec<f64>>
  output value: Stream<Vec<u16>>
{
    ToVoid()
    Linearize()
    ScalToU16(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)
    Organize()

    Self.value -> Linearize.vector,value -> ScalToU16.value,value -> Organize.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern -----------------------------> Organize.pattern
}

use std/conversion/scalar/f64::ToU32 as ScalToU32

/**
Convert stream of `Vec<f64>` into `Vec<u32>` one.

`Vec<f64>` gets converted into `Vec<u32>`, and the resulting vectors are send through stream in continuity.

Every `f64` is truncated to fit into the `u32`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f64` is a positive infinity,
- `neg_infinity` is used when `f64` is a negative infinity,
- `nan` is used when `f64` is not a number.
*/
sequence ToU32(var pos_infinity: u32 = 4294967295, var neg_infinity: u32 = 0, var nan: u32 = 0)
  input  value: Stream<Vec<f64>>
  output value: Stream<Vec<u32>>
{
    ToVoid()
    Linearize()
    ScalToU32(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)
    Organize()

    Self.value -> Linearize.vector,value -> ScalToU32.value,value -> Organize.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern -----------------------------> Organize.pattern
}

use std/conversion/scalar/f64::ToU64 as ScalToU64

/**
Convert stream of `Vec<f64>` into `Vec<u64>` one.

`Vec<f64>` gets converted into `Vec<u64>`, and the resulting vectors are send through stream in continuity.

Every `f64` is truncated to fit into the `u64`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f64` is a positive infinity,
- `neg_infinity` is used when `f64` is a negative infinity,
- `nan` is used when `f64` is not a number.
*/
sequence ToU64(var pos_infinity: u64 = 18446744073709551615, var neg_infinity: u64 = 0, var nan: u64 = 0)
  input  value: Stream<Vec<f64>>
  output value: Stream<Vec<u64>>
{
    ToVoid()
    Linearize()
    ScalToU64(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)
    Organize()

    Self.value -> Linearize.vector,value -> ScalToU64.value,value -> Organize.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern -----------------------------> Organize.pattern
}

use std/conversion/scalar/f64::ToU128 as ScalToU128

/**
Convert stream of `Vec<f64>` into `Vec<u128>` one.

`Vec<f64>` gets converted into `Vec<u128>`, and the resulting vectors are send through stream in continuity.

Every `f64` is truncated to fit into the `u128`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f64` is a positive infinity,
- `neg_infinity` is used when `f64` is a negative infinity,
- `nan` is used when `f64` is not a number.
*/
sequence ToU128(var pos_infinity: u128 = 340282366920938463463374607431768211455, var neg_infinity: u128 = 0, var nan: u128 = 0)
  input  value: Stream<Vec<f64>>
  output value: Stream<Vec<u128>>
{
    ToVoid()
    Linearize()
    ScalToU128(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)
    Organize()

    Self.value -> Linearize.vector,value -> ScalToU128.value,value -> Organize.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern -----------------------------> Organize.pattern
}

use std/conversion/scalar/f64::ToI8 as ScalToI8

/**
Convert stream of `Vec<f64>` into `Vec<i8>` one.

`Vec<f64>` gets converted into `Vec<i8>`, and the resulting vectors are send through stream in continuity.

Every `f64` is truncated to fit into the `i8`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f64` is a positive infinity,
- `neg_infinity` is used when `f64` is a negative infinity,
- `nan` is used when `f64` is not a number.
*/
sequence ToI8(var pos_infinity: i8 = 127, var neg_infinity: i8 = -128, var nan: i8 = 0)
  input  value: Stream<Vec<f64>>
  output value: Stream<Vec<i8>>
{
    ToVoid()
    Linearize()
    ScalToI8(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)
    Organize()

    Self.value -> Linearize.vector,value -> ScalToI8.value,value -> Organize.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern -----------------------------> Organize.pattern
}

use std/conversion/scalar/f64::ToI16 as ScalToI16

/**
Convert stream of `Vec<f64>` into `Vec<i16>` one.

`Vec<f64>` gets converted into `Vec<i16>`, and the resulting vectors are send through stream in continuity.

Every `f64` is truncated to fit into the `i16`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f64` is a positive infinity,
- `neg_infinity` is used when `f64` is a negative infinity,
- `nan` is used when `f64` is not a number.
*/
sequence ToI16(var pos_infinity: i16 = 32767, var neg_infinity: i16 = -32768, var nan: i16 = 0)
  input  value: Stream<Vec<f64>>
  output value: Stream<Vec<i16>>
{
    ToVoid()
    Linearize()
    ScalToI16(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)
    Organize()

    Self.value -> Linearize.vector,value -> ScalToI16.value,value -> Organize.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern -----------------------------> Organize.pattern
}

use std/conversion/scalar/f64::ToI32 as ScalToI32

/**
Convert stream of `Vec<f64>` into `Vec<i32>` one.

`Vec<f64>` gets converted into `Vec<i32>`, and the resulting vectors are send through stream in continuity.

Every `f64` is truncated to fit into the `i32`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f64` is a positive infinity,
- `neg_infinity` is used when `f64` is a negative infinity,
- `nan` is used when `f64` is not a number.
*/
sequence ToI32(var pos_infinity: i32 = 2147483647, var neg_infinity: i32 = -2147483648, var nan: i32 = 0)
  input  value: Stream<Vec<f64>>
  output value: Stream<Vec<i32>>
{
    ToVoid()
    Linearize()
    ScalToI32(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)
    Organize()

    Self.value -> Linearize.vector,value -> ScalToI32.value,value -> Organize.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern -----------------------------> Organize.pattern
}

use std/conversion/scalar/f64::ToI64 as ScalToI64

/**
Convert stream of `Vec<f64>` into `Vec<i64>` one.

`Vec<f64>` gets converted into `Vec<i64>`, and the resulting vectors are send through stream in continuity.

Every `f64` is truncated to fit into the `i64`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f64` is a positive infinity,
- `neg_infinity` is used when `f64` is a negative infinity,
- `nan` is used when `f64` is not a number.
*/
sequence ToI64(var pos_infinity: i64 = 9223372036854775807, var neg_infinity: i64 = -9223372036854775808, var nan: i64 = 0)
  input  value: Stream<Vec<f64>>
  output value: Stream<Vec<i64>>
{
    ToVoid()
    Linearize()
    ScalToI64(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)
    Organize()

    Self.value -> Linearize.vector,value -> ScalToI64.value,value -> Organize.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern -----------------------------> Organize.pattern
}

use std/conversion/scalar/f64::ToI128 as ScalToI128

/**
Convert stream of `Vec<f64>` into `Vec<i128>` one.

`Vec<f64>` gets converted into `Vec<i128>`, and the resulting vectors are send through stream in continuity.

Every `f64` is truncated to fit into the `i128`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f64` is a positive infinity,
- `neg_infinity` is used when `f64` is a negative infinity,
- `nan` is used when `f64` is not a number.
*/
sequence ToI128(var pos_infinity: i128 = 170141183460469231731687303715884105727, var neg_infinity: i128 = -170141183460469231731687303715884105728, var nan: i128 = 0)
  input  value: Stream<Vec<f64>>
  output value: Stream<Vec<i128>>
{
    ToVoid()
    Linearize()
    ScalToI128(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)
    Organize()

    Self.value -> Linearize.vector,value -> ScalToI128.value,value -> Organize.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern -----------------------------> Organize.pattern
}

