use core/arithmetic/scalar::StaticAddI32

/**
Add a static value to `i32`.

Every number passed through the stream get `add` added.
*/
sequence StaticAdd(var add: i32 = 0)
  input  value: Stream<i32>
  output value: Stream<i32>
{
    StaticAddI32(add=add)

    Self.value -> StaticAddI32.value,value -> Self.value
}

use core/arithmetic/scalar::AddI32

/**
Add values from two streams of `i32`.

Values passed through a & b are added and send in sum.

*/
sequence Add()
  input  a:   Stream<i32>
  input  b:   Stream<i32>
  output sum: Stream<i32>
{
    AddI32()

    Self.a -> AddI32.a
    Self.b -> AddI32.b
    
    AddI32.sum -> Self.sum
}

use core/arithmetic/scalar::StaticSubI32 

/**
Substract a static value to `i32`.

Every number passed through the stream get `sub` substracted.

*/
sequence StaticSub(var sub: i32 = 0)
  input  value: Stream<i32>
  output value: Stream<i32>
{
    StaticSubI32(sub=sub)

    Self.value -> StaticSubI32.value,value -> Self.value
}


use core/arithmetic/scalar::SubI32 

/**
Substract values from two streams of `i32`.

Every `a` number passed through the stream get `b` substracted.

*/
sequence Sub()
  input  a:          Stream<i32>
  input  b:          Stream<i32>
  output difference: Stream<i32>
{
    SubI32()

    Self.a -> SubI32.a
    Self.b -> SubI32.b
    
    SubI32.difference -> Self.difference
}


use core/arithmetic/scalar::StaticMultI32 

/**
Multiply `i32` by static value.

Every number passed through the stream is multiplied by `factor`.

*/
sequence StaticMult(var factor: i32 = 0)
  input  value: Stream<i32>
  output value: Stream<i32>
{
    StaticMultI32(factor=factor)

    Self.value -> StaticMultI32.value,value -> Self.value
}


use core/arithmetic/scalar::MultI32 

/**
Multiply values from two streams of `i32`.

Every `a` number passed through the stream is multiplied by `b`.

*/
sequence Mult()
  input  a:       Stream<i32>
  input  b:       Stream<i32>
  output product: Stream<i32>
{
    MultI32()

    Self.a -> MultI32.a
    Self.b -> MultI32.b
    
    MultI32.product -> Self.product
}


use core/arithmetic/scalar::StaticDivI32 

/**
Divide a stream of `i32` by a static value.

Every number passed through the stream is divided by `divisor`.

*/
sequence StaticDiv(var divisor: i32 = 0)
  input  value: Stream<i32>
  output value: Stream<i32>
{
    StaticDivI32(divisor=divisor)

    Self.value -> StaticDivI32.value,value -> Self.value
}


use core/arithmetic/scalar::DivI32 

/**
Divide values from two streams of `i32`.

Every `a` number passed through the stream is divided by `b`.

*/
sequence Div()
  input  a:        Stream<i32>
  input  b:        Stream<i32>
  output quotient: Stream<i32>
{
    DivI32()

    Self.a -> DivI32.a
    Self.b -> DivI32.b
    
    DivI32.quotient -> Self.quotient
}


use core/arithmetic/scalar::StaticRemI32 

/**
Give the remainder of a stream of `i32` divided by a static value.

Every number passed through the stream is divided by `divisor` and the remainder is outputted.

*/
sequence StaticRem(var divisor: i32 = 0)
  input  value: Stream<i32>
  output value: Stream<i32>
{
    StaticRemI32(divisor=divisor)

    Self.value -> StaticRemI32.value,value -> Self.value
}


use core/arithmetic/scalar::RemI32 

/**
Give the remainder of the division from two streams of `i32`.

Every `a` number passed through the stream is divided by `b` and the remainder is outputted.

*/
sequence Rem()
  input  a:         Stream<i32>
  input  b:         Stream<i32>
  output remainder: Stream<i32>
{
    RemI32()

    Self.a -> RemI32.a
    Self.b -> RemI32.b
    
    RemI32.remainder -> Self.remainder
}




use core/arithmetic/scalar::StaticPowI32 

/**
Elevates `i32` to the power of a static value.

Every number passed through the stream get elevated to the power of `exponent`.
*/
sequence StaticPow(var exponent: i32 = 0)
  input  value: Stream<i32>
  output value: Stream<i32>
{
    StaticPowI32(exponent=exponent)

    Self.value -> StaticPowI32.value,value -> Self.value
}


use core/arithmetic/scalar::PowI32 

/**
Elevates values from a stream of `i32` to the power of another one.

Values passed through `base` are elevated to the power of `exponent`.

*/
sequence Pow()
  input  base:     Stream<i32>
  input  exponent: Stream<i32>
  output power:    Stream<i32>
{
    PowI32()

    Self.base -----> PowI32.base
    Self.exponent -> PowI32.exponent
    
    PowI32.power -> Self.power
}

use core/arithmetic/scalar::AbsI32

/**
Get the absolute values from a stream of `i32`.

*/
sequence Abs()
  input  value: Stream<i32>
  output value: Stream<i32>
{
    AbsI32()

    Self.value -> AbsI32.value,value -> Self.value
}
