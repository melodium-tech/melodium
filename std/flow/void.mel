use core/linearize::LinearizeVoid

/**
Linearize stream of `Vec<void>` into stream of `Scalar<void>`.

All the input vectors are turned into continuous stream of scalar values, in the same order.
```mermaid
graph LR
    T(Linearize)
    B["［🟦 🟦］［🟦］［🟦 🟦 🟦］"] -->|vector| T
    
    T -->|value| O["🟦 🟦 🟦 🟦 🟦 🟦"]

    style B fill:#ffff,stroke:#ffff
    style O fill:#ffff,stroke:#ffff
```
*/
sequence Linearize()
  input vector: Stream<Vec<void>>
  output value: Stream<void>
{
    LinearizeVoid()

    Self.vector -> LinearizeVoid.vector,value -> Self.value
}


use core/flow::StreamVoidToBlockVecVoid

/**
Transform whole stream of `void` into a single vector block.

All the streamed values are added to a single vector, and once stream is over the vector is transmitted.

```mermaid
graph LR
    T(BlockAllStream)
    B["🟦 🟦 🟦 🟦 🟦 🟦"] -->|stream| T
    
    T -->|block| O["〈［🟦 🟦 🟦 🟦 🟦 🟦］〉"]

    style B fill:#ffff,stroke:#ffff
    style O fill:#ffff,stroke:#ffff
```

⚠️ As the stream values are continuously inserted in vector and so kept in memory, user should be _really careful_ when using this treatment to not saturate memory.

*/
sequence BlockAllStream()
  input  stream: Stream<void>
  output block:  Block<Vec<void>>
{
    StreamVoidToBlockVecVoid()

    Self.stream -> StreamVoidToBlockVecVoid.data,data -> Self.block
}


use core/flow::BlockVoidToStream

/**
Stream a block of `void`.

The received block is sent as streamed value, then the stream is closed.

```mermaid
graph LR
    T(StreamBlock)
    B["〈🟦〉"] -->|block| T
    
    T -->|stream| O["🟦"]

    style B fill:#ffff,stroke:#ffff
    style O fill:#ffff,stroke:#ffff
```
*/
sequence StreamBlock()
  input  block:  Block<void>
  output stream: Stream<void>
{
    BlockVoidToStream()

    Self.block -> BlockVoidToStream.data,data -> Self.stream
}


use core/flow::BlockVecVoidToStream

/**
Stream a vector of `void`.

The received block is sent as streamed vector, then the stream is closed.

```mermaid
graph LR
    T(StreamVecBlock)
    B["〈［🟦 🟦 🟦 🟦 🟦 🟦］〉"] -->|block| T
    
    T -->|stream| O["［🟦 🟦 🟦 🟦 🟦 🟦］"]

    style B fill:#ffff,stroke:#ffff
    style O fill:#ffff,stroke:#ffff
```
*/
sequence StreamVecBlock()
  input  block:  Block<Vec<void>>
  output stream: Stream<Vec<void>>
{
    BlockVecVoidToStream()

    Self.block -> BlockVecVoidToStream.data,data -> Self.stream
}

use core/flow::Trigger as CoreTrigger

/**
Trigger on `void` stream start and finish.

Send `start` when a first value is send through the stream.
Send `finish` when stream is finally over.

```mermaid
graph LR
    T(Trigger)
    B["🔴 … 🟦 🟦 🟦 🟦 🟦 🟦 … 🟢"] -->|value| T
    
    T -->|start| S["〈🟩〉"]
    T -->|finish| F["〈🟥〉"]

    style B fill:#ffff,stroke:#ffff
    style S fill:#ffff,stroke:#ffff
    style F fill:#ffff,stroke:#ffff
```

ℹ️ If the stream never receive any data before being closed, only `finish` will be emitted.
*/
sequence Trigger()
  input  iter:  Stream<void>
  output start:  Block<void>
  output finish: Block<void>
{
    CoreTrigger()

    Self.iter -----> CoreTrigger.iter
    CoreTrigger.start --> Self.start
    CoreTrigger.finish -> Self.finish
}

/**
Trigger on `Vec<void>` stream start and finish.

Send `start` when a first vector is send through the stream.
Send `finish` when stream is finally over.

```mermaid
graph LR
    T(VecTrigger)
    B["🔴 …［🟦 🟦 🟦］［🟦 🟦 🟦］［🟦 🟦 🟦］［🟦 🟦 🟦］ … 🟢"] -->|value| T
    
    T -->|start| S["〈🟩〉"]
    T -->|finish| F["〈🟥〉"]

    style B fill:#ffff,stroke:#ffff
    style S fill:#ffff,stroke:#ffff
    style F fill:#ffff,stroke:#ffff
```

ℹ️ If the stream never receive any vector before being closed, only `finish` will be emitted.
*/
sequence VecTrigger()
  input  iter:   Stream<Vec<void>>
  output start:  Block<void>
  output finish: Block<void>
{
    Linearize()
    Trigger()

    Self.iter --> Linearize.vector,value -> Trigger.iter
    Trigger.start ------------------------> Self.start
    Trigger.finish -----------------------> Self.finish
}

use core/flow/scalar/void::Count as CoreCount

/**
Gives count of elements passing through input stream.

This count increment one for each elements within the `iter` stream, starting at 1.

```mermaid
graph LR
    T("Count()")
    V["🟦 🟦 🟦…"] -->|iter| T
    
    T -->|count| P["1️⃣ 2️⃣ 3️⃣ …"]

    style V fill:#ffff,stroke:#ffff
    style P fill:#ffff,stroke:#ffff
```
*/
sequence Count()
  input  iter:  Stream<void>
  output count: Stream<u128>
{
    CoreCount()

    Self.iter -> CoreCount.iter,count -> Self.count
}

use core/flow/vector/void::Count as CoreVecCount

/**
Gives count of elements passing through input stream.

This count increment one for each elements within the `iter` stream, starting at 1.

ℹ️ This does not count the number of elements present in each vector, see the `Size` sequence instead.

```mermaid
graph LR
    T("VecCount()")
    V["［🟦 🟦］［🟦］［🟦 🟦 🟦］…"] -->|iter| T
    
    T -->|count| P["1️⃣ 2️⃣ 3️⃣ …"]

    style V fill:#ffff,stroke:#ffff
    style P fill:#ffff,stroke:#ffff
```
*/
sequence VecCount()
  input  iter:  Stream<Vec<void>>
  output count: Stream<u128>
{
    CoreVecCount()

    Self.iter -> CoreVecCount.iter,count -> Self.count
}

use core/flow/vector/void::Size as CoreSize

/**
Gives number of elements present in each vector passing through input stream.

For each vector one `size` value is sent, giving the number of elements contained within matching vector.

```mermaid
graph LR
    T("Size()")
    V["…［🟦 🟦］［🟦］［🟦 🟦 🟦］…"] -->|pattern| T
    
    T -->|size| P["… 2️⃣ 1️⃣ 3️⃣ …"]

    style V fill:#ffff,stroke:#ffff
    style P fill:#ffff,stroke:#ffff
```
*/
sequence Size()
  input  pattern: Stream<Vec<void>>
  output size:    Stream<u64>
{
    CoreSize()

    Self.pattern -> CoreSize.pattern,size -> Self.size
}


use core/flow/vector/void::Fit as CoreFit

/**
Creates stream of vectors based on requested sizes.

For each `size` received, a vector with the same number of values is sent through `pattern`.

```mermaid
graph LR
    T("Fit()")
    V["… 2️⃣ 1️⃣ 3️⃣ …"] -->|size| T
    
    T -->|pattern| P["…［🟦 🟦］［🟦］［🟦 🟦 🟦］…"]

    style V fill:#ffff,stroke:#ffff
    style P fill:#ffff,stroke:#ffff
```
*/
sequence Fit()
  input  size:    Stream<u64>
  output pattern: Stream<Vec<void>>
{
    CoreFit()

    Self.size -> CoreFit.size,pattern -> Self.pattern
}

