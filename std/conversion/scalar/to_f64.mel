
use core/cast/scalar::U8ToF64 as CoreU8ToF64

/**
Convert stream of `u8` into `f64`.

This conversion is lossless, `u8` values can always fit into `f64` ones.
*/
sequence U8ToF64()
  input  value: Stream<u8>
  output value: Stream<f64>
{
    CoreU8ToF64()

    Self.value -> CoreU8ToF64.value,value -> Self.value
}



use core/cast/scalar::U16ToF64 as CoreU16ToF64

/**
Convert stream of `u16` into `f64`.

This conversion is lossless, `u16` values can always fit into `f64` ones.
*/
sequence U16ToF64()
  input  value: Stream<u16>
  output value: Stream<f64>
{
    CoreU16ToF64()

    Self.value -> CoreU16ToF64.value,value -> Self.value
}



use core/cast/scalar::U32ToF64 as CoreU32ToF64

/**
Convert stream of `u32` into `f64`.

This conversion is lossless, `u32` values can always fit into `f64` ones.
*/
sequence U32ToF64()
  input  value: Stream<u32>
  output value: Stream<f64>
{
    CoreU32ToF64()

    Self.value -> CoreU32ToF64.value,value -> Self.value
}



use core/cast/scalar::U64ToF64 as CoreU64ToF64

/**
Convert stream of `u64` into `f64`.

This conversion is lossless, `u64` values can always fit into `f64` ones.
*/
sequence U64ToF64()
  input  value: Stream<u64>
  output value: Stream<f64>
{
    CoreU64ToF64()

    Self.value -> CoreU64ToF64.value,value -> Self.value
}



use core/cast/scalar::U128ToF64 as CoreU128ToF64

/**
Convert stream of `u128` into `f64`.

This conversion is lossless, `u128` values can always fit into `f64` ones.
*/
sequence U128ToF64()
  input  value: Stream<u128>
  output value: Stream<f64>
{
    CoreU128ToF64()

    Self.value -> CoreU128ToF64.value,value -> Self.value
}



use core/cast/scalar::I8ToF64 as CoreI8ToF64

/**
Convert stream of `i8` into `f64`.

This conversion is lossless, `i8` values can always fit into `f64` ones.
*/
sequence I8ToF64()
  input  value: Stream<i8>
  output value: Stream<f64>
{
    CoreI8ToF64()

    Self.value -> CoreI8ToF64.value,value -> Self.value
}



use core/cast/scalar::I16ToF64 as CoreI16ToF64

/**
Convert stream of `i16` into `f64`.

This conversion is lossless, `i16` values can always fit into `f64` ones.
*/
sequence I16ToF64()
  input  value: Stream<i16>
  output value: Stream<f64>
{
    CoreI16ToF64()

    Self.value -> CoreI16ToF64.value,value -> Self.value
}



use core/cast/scalar::I32ToF64 as CoreI32ToF64

/**
Convert stream of `i32` into `f64`.

This conversion is lossless, `i32` values can always fit into `f64` ones.
*/
sequence I32ToF64()
  input  value: Stream<i32>
  output value: Stream<f64>
{
    CoreI32ToF64()

    Self.value -> CoreI32ToF64.value,value -> Self.value
}



use core/cast/scalar::I64ToF64 as CoreI64ToF64

/**
Convert stream of `i64` into `f64`.

This conversion is lossless, `i64` values can always fit into `f64` ones.
*/
sequence I64ToF64()
  input  value: Stream<i64>
  output value: Stream<f64>
{
    CoreI64ToF64()

    Self.value -> CoreI64ToF64.value,value -> Self.value
}



use core/cast/scalar::I128ToF64 as CoreI128ToF64

/**
Convert stream of `i128` into `f64`.

This conversion is lossless, `i128` values can always fit into `f64` ones.
*/
sequence I128ToF64()
  input  value: Stream<i128>
  output value: Stream<f64>
{
    CoreI128ToF64()

    Self.value -> CoreI128ToF64.value,value -> Self.value
}


