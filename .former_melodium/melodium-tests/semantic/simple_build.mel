
/*
 * Computes the HPCP of audio files and render them as images.
 * 
 * This script is a test file for semantic parsing, it is not supposed to be
 * executed at this point.
 * As aimed as example for beginners, it is overdocumented on purpose,
 * repeating even syntaxically explicit expressions.
 *
 * /!\ Be careful when modifying, as tests use this file (especially documentation),
 *     any change may result in tests failures. Check `cargo test` before and after.
 *     
 */

use core/file::FileManager
use core/file::FlatFile
use core/audio::AudioManager
use core/audio::Decoder
use core/audio::Signal

use core/signal::FrameCutter as CoreFrameCutter
use core/signal::Windowing as CoreWindowing
use core/signal::Spectrum as CoreSpectrum
use core/signal::SpectralPeaks as CoreSpectralPeaks
use core/signal::HPCP as CoreHPCP

use std/image::SimpleImageRender

/*
 * Model definition called `Files`, from type `FileManager`.
 * - `directory`: working directory of the file manager
 */
model Files(directory: string): FileManager
{
    // Assignation of the `directory` parameter
    // from model type `FileManager` (left) to 
    // the local parameter `directory` of our `Files`
    // model definition (right).
    directory = directory
}

/*
 * Model definition called `AudioEngine`, from type `AudioManager`.
 */
model AudioEngine(): AudioManager
{
    // Assignation of the `sampleRate` parameter
    // from model type `AudioManager` to the
    // constant `44100`.
    sampleRate = 44100
}

/*
 * Sequence reading files and giving their content to an audio manager
 * for decoding.
 * - `Files`: model of `FileManager`
 * - `Audio`: model of `AudioManager`
 */
sequence ReadAudioFiles[Files: FileManager, Audio: AudioManager]()
    // Declaring treatment `FlatFile` as origin for the sequence,
    // based on `Files` model, called `File`.
    origin File: FlatFile[Files=Files]()
{

    // Declaring treatment `Decoder`, based on `Audio` model.
    Decoder[AudioManager=Audio]()
    
    // Connecting `data` output from `File` to `data` input of `Decoder`.
    File.data -> Decoder.data
}

/*
 * Sequence making the HPCP of an audio signal and saving it as image file.
 * - `AudioManager`: model of `AudioManager`, used as source for audio signals
 * --
 * - `frameSize`: size of frames to use for making spectrum, integer type, default to 4096
 * - `hopSize`: size of hop between each frame, integer type, default to 2048
 * - `windowingType`: type of windowing to use, string type, default to "blackmanharris92"
 */
sequence AudioToHpcpImage[AudioManager: AudioManager](frameSize: u64 = 4096, hopSize: u64 = 2048, windowingType: string = "blackmanharris92")
    // Declaring treatment `Signal` as origin of for the sequence,
    // based on `AudioManager` model, called `AudioSignal`.
    origin AudioSignal: Signal[AudioManager=AudioManager]()
    // Telling that `@File` context is required.
    require @File
    // Telling that `@Signal` context is required.
    require @Signal
{

    // Declaring treatment `Spectrum`, and giving eponyms parameters.
    Spectrum(frameSize=frameSize, hopSize=hopSize, windowingType=windowingType)
    
    // Declaring treatment `HPCP`, and setting up parameters to constants, except `sampleRate`
    // which is assigned to the contextual value `sampleRate` from context `@Signal`.
    HPCP(sampleRate=@Signal[sampleRate], minFrequency=40, maxFrequency=5000, harmonics=8, size=120)
    
    // Declaring treatment `SimpleImageRender`, naming it `Image`, and setting up `fileName`
    // parameter to the contextual value `name` from context `@File`.
    Image: SimpleImageRender(fileName=@File[name], format="png")
    
    // Connecting all declared treatments at once:
    // `signal` output from `AudioSignal` to `signal` input from `Spectrum`,
    // `spectrum` output from `Spectrum` to `spectrum` input from `HPCP`,
    // `hpcp` output from `HPCP` to `input` input of `Image`.
    AudioSignal.signal -> Spectrum.signal,spectrum -> HPCP.spectrum,hpcp -> Image.input
}

/*
 * Sequence being the entry point of the script.
 * - `directory`: string defining where are files to work on
 */
sequence Main(directory: string)
    // Instanciating model `Files` with the given
    // working directory.
    model Files: Files(directory=directory)
    // Instanciating model `AudioEngine` and naming
    // it `Audio`.
    model Audio: AudioEngine()
{

    // Declaring treatment `ReadAudioFiles` and configuring it
    // with `Files` and `Audio` models.
    ReadAudioFiles[Files=Files, AudioManager=Audio]()
    
    // Declaring treatment `AudioToHpcpImage` and configuring it
    // with `Audio` model.
    AudioToHpcpImage[AudioManager=Audio]()
}

/*
 * Sequence computing audio spectrum.
 * - `frameSize`: size of frames to use for making spectrum, integer type
 * - `hopSize`: size of hop between each frame, integer type
 * - `windowingType`: type of windowing to use, string type
 */
sequence Spectrum(frameSize: u64, hopSize: u64, windowingType: string)
    // Declaring input named `signal`, taking a stream of integers.
    input signal: Stream<u64>
    // Declaring output named `spectrum`, taking a stream of vectors of integers.
    output spectrum: Stream<Vec<u64>>
{

    // Declaring treatment `CoreFrameCutter`, setting up parameters `frameSize` and
    // `hopSize` to local eponyms values, and `startFromZero` & `lastFrameToEndOfFile` to constants.
    CoreFrameCutter(frameSize=frameSize, hopSize=hopSize, startFromZero=true, lastFrameToEndOfFile=true)
    
    // Declaring treatment `CoreWindowing`, setting up parameters `type` and
    // `size` to local values of `windowingType` and `frameSize` respectively.
    CoreWindowing(type=windowingType, size=frameSize)
    
    // Declaring treatment `CoreSpectrum`, setting up parameters `size` to local value `frameSize`.
    CoreSpectrum(size=frameSize)

    // Connecting all declared treatments at once:
    // `signal` input from this sequence to `signal` input from `CoreFrameCutter`,
    // `frame` output from `CoreFrameCutter` to `frame` input from `CoreWindowing`,
    // `frame` output from `CoreWindowing` to `frame` input from `CoreSpectrum`,
    // `spectrum` output from `CoreSpectrum` to `spectrum` output from this sequence,
    Self.signal -> CoreFrameCutter.signal,frame -> CoreWindowing.frame,frame -> CoreSpectrum.frame,spectrum -> Self.spectrum
}

/*
 * Sequence computing the HPCP of a spectrum.
 * - `sampleRate`: sample rate used for the spectral analysis, integer type, default to 44100
 * - `minFrequency`: minimal frequency of HPCP, integer type, default to 50
 * - `maxFrequency`: maximal frequency of HPCP, integer type, default to 1000
 * - `harmonics`: number of harmonics to include in HPCP, integer type, default to 8
 * - `size`: size of the HPCP, integer type, default to 120
 */
sequence HPCP(sampleRate: u64 = 44100, minFrequency: u64 = 50, maxFrequency: u64 = 1000, harmonics: u64 = 8, size: u64 = 120)
    // Declaring input named `spectrum`, taking a matrix of integers.
    input spectrum: Stream<Vec<u64>>
    // Declaring output named `hpcp`, taking a matrix of integers.
    output hpcp: Stream<Vec<u64>>
{

    // Declaring treatment `CoreSpectralPeaks`, setting up parameters `sampleRate`, `minFrequency`, and
    // `maxFrequency` to local eponyms values, and `orderBy`, `magnitudeThreshold` and `maxPeaks` to constants.
    CoreSpectralPeaks(sampleRate=sampleRate, orderBy="magnitude", magnitudeThreshold=0.00001, minFrequency=minFrequency, maxFrequency=maxFrequency, maxPeaks=10000)
    
    // Declaring treatment `CoreHPCP`, setting up parameters `sampleRate`, `harmonics` and
    // `size` to local eponyms values, and `windowSize` & `weightType` to constants.
    CoreHPCP(sampleRate=sampleRate, windowSize=0.5, harmonics=harmonics, weightType="cosine", size=size)

    // Connecting input `spectrum` from this sequence to `spectrum` input from `CoreSpectralPeaks`.
    Self.spectrum ------------------> CoreSpectralPeaks.spectrum
    
    // Connecting outputs `frequencies` and `magnitudes` from `CoreSpectralPeaks` to
    // the eponym inputs from `CoreHPCP`.
    CoreSpectralPeaks.frequencies --> CoreHPCP.frequencies
    CoreSpectralPeaks.magnitudes ---> CoreHPCP.magnitudes
    
    // Connecting output `hpcp` from `CoreHPCP` to `hpcp` output from this sequence.
    CoreHPCP.hpcp ------------------> Self.hpcp
}


