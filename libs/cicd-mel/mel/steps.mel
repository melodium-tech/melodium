use process/command::Command
use process/environment::Environment
use process/exec::Executor
use process/exec::spawn
use std/data/string_map::|map
use std/flow::emit
use std/flow::one
use std/flow::stream
use std/flow::waitBlock
use std/flow/vec::flatten
use log/log::logInfos
use log/log::logErrors
use log/log::logError
use log/logger::Log
use log/logger::Logger
use log/logger::trackLogs
use log/logger::logs
use log/logger::injectStreamLog
use work/distant::DistantEngine
use work/distant::distant
use work/resources::getExecutor
use distrib::distribute
use distrib::sendBlock
use distrib::sendStream
use distrib::recvBlock
use distrib::recvStream
use root/data::ioToString
use root/runners::CicdDistributionEngine

treatment stepOn[distributor: CicdDistributionEngine, logger: Logger](var executor_name: string, var environment: Option<Environment> = _, var commands: Vec<Command>)
  input trigger: Block<void>
  output started: Block<void>
  output finished: Block<void>
  output failed: Block<void>
  output completed: Block<void>
{
    distribute[distributor=distributor]()

    Self.trigger -> distribute.trigger

    logDistribErr: logError[logger=logger](label="distribution")
    distribute.error -> logDistribErr.message

    distribOrStepFailed: one<void>()
    distribute.failed -> distribOrStepFailed.a

    sendTriggerLogs: sendBlock<void>[distributor=distributor](name="trigger_logs")
    sendExecutorName: sendBlock<string>[distributor=distributor](name="executor_name")
    sendEnvironment: sendBlock<Option<Environment>>[distributor=distributor](name="environment")
    sendCommands: sendStream<Command>[distributor=distributor](name="commands")

    recvStarted: recvBlock<void>[distributor=distributor](name="started")
    recvFinished: recvBlock<void>[distributor=distributor](name="finished")
    recvFailed: recvBlock<void>[distributor=distributor](name="failed")
    recvCompleted: recvBlock<void>[distributor=distributor](name="completed")
    recvLogs: recvStream<Log>[distributor=distributor](name="logs")

    distribute.distribution_id -> sendTriggerLogs.distribution_id
    distribute.distribution_id -> sendExecutorName.distribution_id
    distribute.distribution_id -> sendEnvironment.distribution_id
    distribute.distribution_id -> sendCommands.distribution_id
    distribute.distribution_id -> recvStarted.distribution_id
    distribute.distribution_id -> recvFinished.distribution_id
    distribute.distribution_id -> recvFailed.distribution_id
    distribute.distribution_id -> recvCompleted.distribution_id
    distribute.distribution_id -> recvLogs.distribution_id

    emitExecutorName: emit<string>(value=executor_name)
    emitEnvironment: emit<Option<Environment>>(value=environment)
    emitCommands: emit<Vec<Command>>(value=commands)
    streamCommands: stream<Vec<Command>>()
    flattenCommands: flatten<Command>()

    Self.trigger -> sendTriggerLogs.data
    Self.trigger -> emitExecutorName.trigger,emit -> sendExecutorName.data
    Self.trigger -> emitEnvironment.trigger,emit --> sendEnvironment.data
    Self.trigger -> emitCommands.trigger,emit -> streamCommands.block,stream -> flattenCommands.vector,value -> sendCommands.data

    injectStreamLog[logger=logger]()
    recvLogs.data -> injectStreamLog.logs

    recvStarted.data -> Self.started
    recvFinished.data -> Self.finished
    recvFailed.data -> distribOrStepFailed.b,value -> Self.failed
    recvCompleted.data -> Self.completed
}

treatment step(var label: string)
  input trigger_logs: Block<void>
  input executor_name: Block<string>
  input environment: Block<Option<Environment>>
  input commands: Stream<Command>
  output started: Block<void>
  output finished: Block<void>
  output failed: Block<void>
  output completed: Block<void>
  output logs: Stream<Log>
  model  logger: Logger()
{
    getExecutor()
    spawn()

    Self.executor_name -> getExecutor.name,executor -> spawn.executor
    Self.environment --------------------------------> spawn.environment
    Self.commands -----------------------------------> spawn.commands

    executorOrSpawnFailed: one<void>()
    getExecutor.failed -> executorOrSpawnFailed.a
    spawn.failed -------> executorOrSpawnFailed.b

    logExecutorErr: logError[logger=logger](label=label)
    getExecutor.error -> logExecutorErr.message

    logSpawnErr: logError[logger=logger](label=label)
    logSpawnErrsString: ioToString()
    logSpawnErrs: logErrors[logger=logger](label=label)
    logSpawnInfosString: ioToString()
    logSpawnInfos: logInfos[logger=logger](label=label)
    spawn.error --> logSpawnErr.message
    spawn.stderr -> logSpawnErrsString.stdio,lines -> logSpawnErrs.messages
    spawn.stdout -> logSpawnInfosString.stdio,lines -> logSpawnInfos.messages

    waitAllMessages: waitBlock<void>()
    waitSpawnFinishedAndAllMessages: waitBlock<void>()

    logSpawnErrs.ended --> waitAllMessages.a
    logSpawnInfos.ended -> waitAllMessages.b,awaited -> waitSpawnFinishedAndAllMessages.a
    spawn.finished -----------------------------------> waitSpawnFinishedAndAllMessages.b

    spawn.started ----------------------------> Self.started
    waitSpawnFinishedAndAllMessages.awaited --> Self.finished
    executorOrSpawnFailed.value --------------> Self.failed
    spawn.completed --------------------------> Self.completed

    trackLogs[logger=logger]()
    Self.trigger_logs -> trackLogs.trigger,logs --> Self.logs
    waitSpawnFinishedAndAllMessages.awaited -> trackLogs.stop
}