use core/linearize::LinearizeF32

/**
Linearize stream of `Vec<f32>` into stream of `Scalar<f32>`.

All the input vectors are turned into continuous stream of scalar values, in the same order.
```mermaid
graph LR
    T(Linearize)
    B["ï¼»ğŸŸ¦Â ğŸŸ¦ï¼½ï¼»ğŸŸ¦ï¼½ï¼»ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦ï¼½"] -->|vector| T
    
    T -->|value| O["ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦"]

    style B fill:#ffff,stroke:#ffff
    style O fill:#ffff,stroke:#ffff
```
*/
sequence Linearize()
  input vector: Stream<Vec<f32>>
  output value: Stream<f32>
{
    LinearizeF32()

    Self.vector -> LinearizeF32.vector,value -> Self.value
}


use core/flow::StreamF32ToBlockVecF32

/**
Transform stream of `f32` into a single vector block.

All the streamed values are added to a single vector, and once stream is over the vector is transmitted.

```mermaid
graph LR
    T(BlockStream)
    B["ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦"] -->|stream| T
    
    T -->|block| O["ã€ˆï¼»ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦ï¼½ã€‰"]

    style B fill:#ffff,stroke:#ffff
    style O fill:#ffff,stroke:#ffff
```

âš ï¸ As the stream values are continuously inserted in vector and so kept in memory, user should be _really careful_ when using this treatment to not saturate memory.

*/
sequence BlockStream()
  input  stream: Stream<f32>
  output block:  Block<Vec<f32>>
{
    StreamF32ToBlockVecF32()

    Self.stream -> StreamF32ToBlockVecF32.data,data -> Self.block
}


use core/flow::BlockVecF32ToStreamF32

/**
Stream a vector of `f32`.

All values received in block vector are streamed ordered in output.

```mermaid
graph LR
    T(StreamBlock)
    B["ã€ˆï¼»ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦ï¼½ã€‰"] -->|block| T
    
    T -->|stream| O["ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦"]

    style B fill:#ffff,stroke:#ffff
    style O fill:#ffff,stroke:#ffff
```
*/
sequence StreamBlock()
  input  block:  Block<Vec<f32>>
  output stream: Stream<f32>
{
    BlockVecF32ToStreamF32()

    Self.block -> BlockVecF32ToStreamF32.data,data -> Self.stream
}

use core/organize::OrganizeF32

/**
Organize stream of `f32` into stream of `Vec<f32>`.

â„¹ï¸ If some remaining values doesn't fit into the pattern, they are trashed.
If there are not enough values to fit the pattern, uncomplete vector is trashed.

```mermaid
graph LR
    T(Organize)
    A["â€¦ ğŸŸ¨Â ğŸŸ¨Â ğŸŸ¨Â ğŸŸ¨Â ğŸŸ¨Â ğŸŸ¨"] -->|value| T
    B["[ğŸŸ¦Â ğŸŸ¦]Â [ğŸŸ¦]Â [ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦]"] -->|pattern| T
    
    T -->|values| O["[ğŸŸ¨Â ğŸŸ¨]Â [ğŸŸ¨]Â [ğŸŸ¨Â ğŸŸ¨Â ğŸŸ¨]"]

    style A fill:#ffff,stroke:#ffff
    style B fill:#ffff,stroke:#ffff
    style O fill:#ffff,stroke:#ffff
```

*/
sequence Organize()
  input   value: Stream<f32>
  input pattern: Stream<Vec<void>>
  output values: Stream<Vec<f32>>
{
    OrganizeF32()

    Self.value ---> OrganizeF32.value,values -> Self.values
    Self.pattern -> OrganizeF32.pattern
}


use std/flow/void::Trigger as VoidTrigger
use std/conversion/scalar/f32::ToVoid

/**
Trigger on `f32` stream start and finish.

Send `start` when a first value is send through the stream.
Send `finish` when stream is finally over.

```mermaid
graph LR
    T(Trigger)
    B["ğŸ”´Â â€¦ ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â â€¦Â ğŸŸ¢"] -->|value| T
    
    T -->|start| S["ã€ˆğŸŸ©ã€‰"]
    T -->|finish| F["ã€ˆğŸŸ¥ã€‰"]

    style B fill:#ffff,stroke:#ffff
    style S fill:#ffff,stroke:#ffff
    style F fill:#ffff,stroke:#ffff
```

â„¹ï¸ If the stream never receive any data before being closed, only `finish` will be emitted.
*/
sequence Trigger()
  input  value:  Stream<f32>
  output start:  Block<void>
  output finish: Block<void>
{
    ToVoid()
    VoidTrigger()

    Self.value -> ToVoid.value,iter -> VoidTrigger.iter
    VoidTrigger.start --> Self.start
    VoidTrigger.finish -> Self.finish
}


use std/flow/void::VecTrigger as VoidVecTrigger
use std/conversion/vector/f32::ToVoid as ToVecVoid

/**
Trigger on `Vec<f32>` stream start and finish.

Send `start` when a first vector is send through the stream.
Send `finish` when stream is finally over.

```mermaid
graph LR
    T(VecTrigger)
    B["ğŸ”´Â â€¦ï¼»ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦ï¼½ï¼»ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦ï¼½ï¼»ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦ï¼½ï¼»ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦ï¼½Â â€¦Â ğŸŸ¢"] -->|value| T
    
    T -->|start| S["ã€ˆğŸŸ©ã€‰"]
    T -->|finish| F["ã€ˆğŸŸ¥ã€‰"]

    style B fill:#ffff,stroke:#ffff
    style S fill:#ffff,stroke:#ffff
    style F fill:#ffff,stroke:#ffff
```

â„¹ï¸ If the stream never receive any vector before being closed, only `finish` will be emitted.
*/
sequence VecTrigger()
  input  value:  Stream<Vec<f32>>
  output start:  Block<void>
  output finish: Block<void>
{
    ToVecVoid()
    VoidVecTrigger()

    Self.value -> ToVecVoid.vector,pattern -> VoidVecTrigger.iter
    VoidVecTrigger.start --> Self.start
    VoidVecTrigger.finish -> Self.finish
}