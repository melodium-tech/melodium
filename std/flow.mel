
use core/flow::StreamU8ToBlockVecU8
use core/flow::BlockVecU8ToStreamU8

/**
Transform stream of `u8` into a single vector block.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.

⚠️ As the stream values are continuously inserted in vector and so kept in memory, user should be _really careful_ when using this treatment to not saturate memory.

*/
sequence BlockStreamU8()
  input  stream: Stream<u8>
  output block:  Block<Vec<u8>>
{
    StreamU8ToBlockVecU8()

    Self.stream -> StreamU8ToBlockVecU8.data,data -> Self.block
}

/**
Stream a vector of `u8`.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.
The received block vector is streamed in output.
*/
sequence StreamBlockU8()
  input  block:  Block<Vec<u8>>
  output stream: Stream<u8>
{
    BlockVecU8ToStreamU8()

    Self.block -> BlockVecU8ToStreamU8.data,data -> Self.stream
}



use core/flow::StreamU16ToBlockVecU16
use core/flow::BlockVecU16ToStreamU16

/**
Transform stream of `u16` into a single vector block.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.

⚠️ As the stream values are continuously inserted in vector and so kept in memory, user should be _really careful_ when using this treatment to not saturate memory.

*/
sequence BlockStreamU16()
  input  stream: Stream<u16>
  output block:  Block<Vec<u16>>
{
    StreamU16ToBlockVecU16()

    Self.stream -> StreamU16ToBlockVecU16.data,data -> Self.block
}

/**
Stream a vector of `u16`.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.
The received block vector is streamed in output.
*/
sequence StreamBlockU16()
  input  block:  Block<Vec<u16>>
  output stream: Stream<u16>
{
    BlockVecU16ToStreamU16()

    Self.block -> BlockVecU16ToStreamU16.data,data -> Self.stream
}



use core/flow::StreamU32ToBlockVecU32
use core/flow::BlockVecU32ToStreamU32

/**
Transform stream of `u32` into a single vector block.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.

⚠️ As the stream values are continuously inserted in vector and so kept in memory, user should be _really careful_ when using this treatment to not saturate memory.

*/
sequence BlockStreamU32()
  input  stream: Stream<u32>
  output block:  Block<Vec<u32>>
{
    StreamU32ToBlockVecU32()

    Self.stream -> StreamU32ToBlockVecU32.data,data -> Self.block
}

/**
Stream a vector of `u32`.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.
The received block vector is streamed in output.
*/
sequence StreamBlockU32()
  input  block:  Block<Vec<u32>>
  output stream: Stream<u32>
{
    BlockVecU32ToStreamU32()

    Self.block -> BlockVecU32ToStreamU32.data,data -> Self.stream
}



use core/flow::StreamU64ToBlockVecU64
use core/flow::BlockVecU64ToStreamU64

/**
Transform stream of `u64` into a single vector block.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.

⚠️ As the stream values are continuously inserted in vector and so kept in memory, user should be _really careful_ when using this treatment to not saturate memory.

*/
sequence BlockStreamU64()
  input  stream: Stream<u64>
  output block:  Block<Vec<u64>>
{
    StreamU64ToBlockVecU64()

    Self.stream -> StreamU64ToBlockVecU64.data,data -> Self.block
}

/**
Stream a vector of `u64`.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.
The received block vector is streamed in output.
*/
sequence StreamBlockU64()
  input  block:  Block<Vec<u64>>
  output stream: Stream<u64>
{
    BlockVecU64ToStreamU64()

    Self.block -> BlockVecU64ToStreamU64.data,data -> Self.stream
}



use core/flow::StreamU128ToBlockVecU128
use core/flow::BlockVecU128ToStreamU128

/**
Transform stream of `u128` into a single vector block.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.

⚠️ As the stream values are continuously inserted in vector and so kept in memory, user should be _really careful_ when using this treatment to not saturate memory.

*/
sequence BlockStreamU128()
  input  stream: Stream<u128>
  output block:  Block<Vec<u128>>
{
    StreamU128ToBlockVecU128()

    Self.stream -> StreamU128ToBlockVecU128.data,data -> Self.block
}

/**
Stream a vector of `u128`.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.
The received block vector is streamed in output.
*/
sequence StreamBlockU128()
  input  block:  Block<Vec<u128>>
  output stream: Stream<u128>
{
    BlockVecU128ToStreamU128()

    Self.block -> BlockVecU128ToStreamU128.data,data -> Self.stream
}



use core/flow::StreamI8ToBlockVecI8
use core/flow::BlockVecI8ToStreamI8

/**
Transform stream of `i8` into a single vector block.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.

⚠️ As the stream values are continuously inserted in vector and so kept in memory, user should be _really careful_ when using this treatment to not saturate memory.

*/
sequence BlockStreamI8()
  input  stream: Stream<i8>
  output block:  Block<Vec<i8>>
{
    StreamI8ToBlockVecI8()

    Self.stream -> StreamI8ToBlockVecI8.data,data -> Self.block
}

/**
Stream a vector of `i8`.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.
The received block vector is streamed in output.
*/
sequence StreamBlockI8()
  input  block:  Block<Vec<i8>>
  output stream: Stream<i8>
{
    BlockVecI8ToStreamI8()

    Self.block -> BlockVecI8ToStreamI8.data,data -> Self.stream
}



use core/flow::StreamI16ToBlockVecI16
use core/flow::BlockVecI16ToStreamI16

/**
Transform stream of `i16` into a single vector block.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.

⚠️ As the stream values are continuously inserted in vector and so kept in memory, user should be _really careful_ when using this treatment to not saturate memory.

*/
sequence BlockStreamI16()
  input  stream: Stream<i16>
  output block:  Block<Vec<i16>>
{
    StreamI16ToBlockVecI16()

    Self.stream -> StreamI16ToBlockVecI16.data,data -> Self.block
}

/**
Stream a vector of `i16`.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.
The received block vector is streamed in output.
*/
sequence StreamBlockI16()
  input  block:  Block<Vec<i16>>
  output stream: Stream<i16>
{
    BlockVecI16ToStreamI16()

    Self.block -> BlockVecI16ToStreamI16.data,data -> Self.stream
}



use core/flow::StreamI32ToBlockVecI32
use core/flow::BlockVecI32ToStreamI32

/**
Transform stream of `i32` into a single vector block.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.

⚠️ As the stream values are continuously inserted in vector and so kept in memory, user should be _really careful_ when using this treatment to not saturate memory.

*/
sequence BlockStreamI32()
  input  stream: Stream<i32>
  output block:  Block<Vec<i32>>
{
    StreamI32ToBlockVecI32()

    Self.stream -> StreamI32ToBlockVecI32.data,data -> Self.block
}

/**
Stream a vector of `i32`.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.
The received block vector is streamed in output.
*/
sequence StreamBlockI32()
  input  block:  Block<Vec<i32>>
  output stream: Stream<i32>
{
    BlockVecI32ToStreamI32()

    Self.block -> BlockVecI32ToStreamI32.data,data -> Self.stream
}



use core/flow::StreamI64ToBlockVecI64
use core/flow::BlockVecI64ToStreamI64

/**
Transform stream of `i64` into a single vector block.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.

⚠️ As the stream values are continuously inserted in vector and so kept in memory, user should be _really careful_ when using this treatment to not saturate memory.

*/
sequence BlockStreamI64()
  input  stream: Stream<i64>
  output block:  Block<Vec<i64>>
{
    StreamI64ToBlockVecI64()

    Self.stream -> StreamI64ToBlockVecI64.data,data -> Self.block
}

/**
Stream a vector of `i64`.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.
The received block vector is streamed in output.
*/
sequence StreamBlockI64()
  input  block:  Block<Vec<i64>>
  output stream: Stream<i64>
{
    BlockVecI64ToStreamI64()

    Self.block -> BlockVecI64ToStreamI64.data,data -> Self.stream
}



use core/flow::StreamI128ToBlockVecI128
use core/flow::BlockVecI128ToStreamI128

/**
Transform stream of `i128` into a single vector block.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.

⚠️ As the stream values are continuously inserted in vector and so kept in memory, user should be _really careful_ when using this treatment to not saturate memory.

*/
sequence BlockStreamI128()
  input  stream: Stream<i128>
  output block:  Block<Vec<i128>>
{
    StreamI128ToBlockVecI128()

    Self.stream -> StreamI128ToBlockVecI128.data,data -> Self.block
}

/**
Stream a vector of `i128`.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.
The received block vector is streamed in output.
*/
sequence StreamBlockI128()
  input  block:  Block<Vec<i128>>
  output stream: Stream<i128>
{
    BlockVecI128ToStreamI128()

    Self.block -> BlockVecI128ToStreamI128.data,data -> Self.stream
}



use core/flow::StreamF32ToBlockVecF32
use core/flow::BlockVecF32ToStreamF32

/**
Transform stream of `f32` into a single vector block.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.

⚠️ As the stream values are continuously inserted in vector and so kept in memory, user should be _really careful_ when using this treatment to not saturate memory.

*/
sequence BlockStreamF32()
  input  stream: Stream<f32>
  output block:  Block<Vec<f32>>
{
    StreamF32ToBlockVecF32()

    Self.stream -> StreamF32ToBlockVecF32.data,data -> Self.block
}

/**
Stream a vector of `f32`.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.
The received block vector is streamed in output.
*/
sequence StreamBlockF32()
  input  block:  Block<Vec<f32>>
  output stream: Stream<f32>
{
    BlockVecF32ToStreamF32()

    Self.block -> BlockVecF32ToStreamF32.data,data -> Self.stream
}



use core/flow::StreamF64ToBlockVecF64
use core/flow::BlockVecF64ToStreamF64

/**
Transform stream of `f64` into a single vector block.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.

⚠️ As the stream values are continuously inserted in vector and so kept in memory, user should be _really careful_ when using this treatment to not saturate memory.

*/
sequence BlockStreamF64()
  input  stream: Stream<f64>
  output block:  Block<Vec<f64>>
{
    StreamF64ToBlockVecF64()

    Self.stream -> StreamF64ToBlockVecF64.data,data -> Self.block
}

/**
Stream a vector of `f64`.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.
The received block vector is streamed in output.
*/
sequence StreamBlockF64()
  input  block:  Block<Vec<f64>>
  output stream: Stream<f64>
{
    BlockVecF64ToStreamF64()

    Self.block -> BlockVecF64ToStreamF64.data,data -> Self.stream
}



use core/flow::StreamBoolToBlockVecBool
use core/flow::BlockVecBoolToStreamBool

/**
Transform stream of `bool` into a single vector block.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.

⚠️ As the stream values are continuously inserted in vector and so kept in memory, user should be _really careful_ when using this treatment to not saturate memory.

*/
sequence BlockStreamBool()
  input  stream: Stream<bool>
  output block:  Block<Vec<bool>>
{
    StreamBoolToBlockVecBool()

    Self.stream -> StreamBoolToBlockVecBool.data,data -> Self.block
}

/**
Stream a vector of `bool`.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.
The received block vector is streamed in output.
*/
sequence StreamBlockBool()
  input  block:  Block<Vec<bool>>
  output stream: Stream<bool>
{
    BlockVecBoolToStreamBool()

    Self.block -> BlockVecBoolToStreamBool.data,data -> Self.stream
}



use core/flow::StreamByteToBlockVecByte
use core/flow::BlockVecByteToStreamByte

/**
Transform stream of `byte` into a single vector block.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.

⚠️ As the stream values are continuously inserted in vector and so kept in memory, user should be _really careful_ when using this treatment to not saturate memory.

*/
sequence BlockStreamByte()
  input  stream: Stream<byte>
  output block:  Block<Vec<byte>>
{
    StreamByteToBlockVecByte()

    Self.stream -> StreamByteToBlockVecByte.data,data -> Self.block
}

/**
Stream a vector of `byte`.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.
The received block vector is streamed in output.
*/
sequence StreamBlockByte()
  input  block:  Block<Vec<byte>>
  output stream: Stream<byte>
{
    BlockVecByteToStreamByte()

    Self.block -> BlockVecByteToStreamByte.data,data -> Self.stream
}



use core/flow::StreamCharToBlockVecChar
use core/flow::BlockVecCharToStreamChar

/**
Transform stream of `char` into a single vector block.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.

⚠️ As the stream values are continuously inserted in vector and so kept in memory, user should be _really careful_ when using this treatment to not saturate memory.

*/
sequence BlockStreamChar()
  input  stream: Stream<char>
  output block:  Block<Vec<char>>
{
    StreamCharToBlockVecChar()

    Self.stream -> StreamCharToBlockVecChar.data,data -> Self.block
}

/**
Stream a vector of `char`.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.
The received block vector is streamed in output.
*/
sequence StreamBlockChar()
  input  block:  Block<Vec<char>>
  output stream: Stream<char>
{
    BlockVecCharToStreamChar()

    Self.block -> BlockVecCharToStreamChar.data,data -> Self.stream
}



use core/flow::StreamStringToBlockVecString
use core/flow::BlockVecStringToStreamString

/**
Transform stream of `string` into a single vector block.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.

⚠️ As the stream values are continuously inserted in vector and so kept in memory, user should be _really careful_ when using this treatment to not saturate memory.

*/
sequence BlockStreamString()
  input  stream: Stream<string>
  output block:  Block<Vec<string>>
{
    StreamStringToBlockVecString()

    Self.stream -> StreamStringToBlockVecString.data,data -> Self.block
}

/**
Stream a vector of `string`.

All the streamed value are added to a single vector, and once stream is over the vector is transmitted.
The received block vector is streamed in output.
*/
sequence StreamBlockString()
  input  block:  Block<Vec<string>>
  output stream: Stream<string>
{
    BlockVecStringToStreamString()

    Self.block -> BlockVecStringToStreamString.data,data -> Self.stream
}


