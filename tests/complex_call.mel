#!/usr/bin/env melodium
#! name = fs_test
#! version = 0.7.1
#! require = flow:0.7.1
#! require = engine:0.7.1
#! require = conv:0.7.1
#! require = fs:0.7.1

use engine/util::startup
use flow/void::generate
use flow/u128::emit
use flow/string::fill
use flow/string::count
use flow/u128::trigger
use flow/u128::stream
use fs/file::write
use flow/string::emit as emitPath
use conv/u128::toByte
use flow/vec/byte::flatten

treatment main(const content: string = "this is some text", var generate: u128 = 876, const output: string = "./output_count") {
    startup()
    generate_arbitrary(length = generate, text = content)
    count_writer(output_file = output)

    startup.trigger -> generate_arbitrary.trigger,generated -> count_writer.text
}

treatment generate_arbitrary(var length: u128, const text: string)
  input trigger: Block<void>
  output generated: Stream<string>
{
    effective_generator(size = length)
    converter(content = text)

    Self.trigger -> effective_generator.trigger,data -> converter.stream,text -> Self.generated
}

treatment effective_generator(var size: u128)
  input trigger: Block<void>
  output data: Stream<void>
{
    generate()
    emit(value=size)

    Self.trigger -> emit.trigger,emit -> generate.length,stream -> Self.data 
}

treatment converter(var content: string)
  input stream: Stream<void>
  output text: Stream<string>
{
    fill(value=content)

    Self.stream -> fill.pattern,filled -> Self.text
}

treatment count_writer(var output_file: string)
    input text: Stream<string>
{
    count()
    trigger()
    stream()
    write()
    emitPath(value=output_file)
    toByte()
    flatten()

    Self.text -> count.stream,count -> trigger.stream,last -> stream.block,stream -> toByte.value,data -> flatten.vector,value -> write.data
    trigger.end -> emitPath.trigger,emit -> write.path
}

