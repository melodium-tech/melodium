use std/flow/f32::Linearize

use core/conversion/vector::F32ToVoid

/**
Convert stream of `Vec<f32>` into `Vec<void>` one.

This conversion is useful to extract pattern from a stream of vectors and work on it.

*/
sequence ToVoid()
  input  vector:  Stream<Vec<f32>>
  output pattern: Stream<Vec<void>>
{
    F32ToVoid()

    Self.vector -> F32ToVoid.vector,pattern -> Self.pattern
}

use std/conversion/scalar/f32::ToByte as ScalToByte
use std/flow/byte::Organize as OrganizeByte

/**
Convert stream of `Vec<f32>` into `Vec<byte>` one.

`Vec<f32>` gets converted into `Vec<byte>`, and the resulting vectors are send through stream in continuity.
*/
sequence ToByte()
  input  value: Stream<Vec<f32>>
  output data:  Stream<Vec<byte>>
{
    ToVoid()
    Linearize()
    ScalToByte()
    OrganizeByte()

    Self.value -> Linearize.vector,value -> ScalToByte.value,data -> OrganizeByte.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern ---------------------------> OrganizeByte.pattern
}

use std/conversion/scalar/f32::ToString as ScalToString
use std/flow/string::Organize as OrganizeString

/**
Convert stream of `Vec<f32>` into `Vec<string>` one.

`Vec<f32>` gets converted into `Vec<string>`, and the resulting vectors are send through stream in continuity.
*/
sequence ToString()
  input  value: Stream<Vec<f32>>
  output value: Stream<Vec<string>>
{
    ToVoid()
    Linearize()
    ScalToString()
    OrganizeString()

    Self.value -> Linearize.vector,value -> ScalToString.value,value -> OrganizeString.value,values -> Self.value
    Self.value -> ToVoid.vector,pattern ------------------------------> OrganizeString.pattern
}

use std/conversion/scalar/f32::ToF64 as ScalToF64
use std/flow/f64::Organize as OrganizeF64

/**
Convert stream of `Vec<f32>` into `Vec<f64>` one.

`Vec<f32>` gets converted into `Vec<f64>`, and the resulting vectors are send through stream in continuity.

Every `f32` is fitted into the closest `f64`.
Positive and negative infinity are conserved, as well as not-a-number state.
If overflowing, infinity of the same sign is used.
*/
sequence ToF64()
  input  value: Stream<Vec<f32>>
  output value: Stream<Vec<f64>>
{
    ToVoid()
    Linearize()
    ScalToF64()
    OrganizeF64()

    Self.value -> Linearize.vector,value -> ScalToF64.value,value -> OrganizeF64.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern -----------------------------> OrganizeF64.pattern
}use std/conversion/scalar/f32::ToU8 as ScalToU8
use std/flow/u8::Organize as OrganizeU8

/**
Convert stream of `Vec<f32>` into `Vec<u8>` one.

`Vec<f32>` gets converted into `Vec<u8>`, and the resulting vectors are send through stream in continuity.

Every `f32` is truncated to fit into the `u8`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f32` is a positive infinity,
- `neg_infinity` is used when `f32` is a negative infinity,
- `nan` is used when `f32` is not a number.
*/
sequence ToU8(var pos_infinity: u8 = 255, var neg_infinity: u8 = 0, var nan: u8 = 0)
  input  value: Stream<Vec<f32>>
  output value: Stream<Vec<u8>>
{
    ToVoid()
    Linearize()
    ScalToU8(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)
    OrganizeU8()

    Self.value -> Linearize.vector,value -> ScalToU8.value,value -> OrganizeU8.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern -----------------------------> OrganizeU8.pattern
}

use std/conversion/scalar/f32::ToU16 as ScalToU16
use std/flow/u16::Organize as OrganizeU16

/**
Convert stream of `Vec<f32>` into `Vec<u16>` one.

`Vec<f32>` gets converted into `Vec<u16>`, and the resulting vectors are send through stream in continuity.

Every `f32` is truncated to fit into the `u16`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f32` is a positive infinity,
- `neg_infinity` is used when `f32` is a negative infinity,
- `nan` is used when `f32` is not a number.
*/
sequence ToU16(var pos_infinity: u16 = 65535, var neg_infinity: u16 = 0, var nan: u16 = 0)
  input  value: Stream<Vec<f32>>
  output value: Stream<Vec<u16>>
{
    ToVoid()
    Linearize()
    ScalToU16(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)
    OrganizeU16()

    Self.value -> Linearize.vector,value -> ScalToU16.value,value -> OrganizeU16.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern -----------------------------> OrganizeU16.pattern
}

use std/conversion/scalar/f32::ToU32 as ScalToU32
use std/flow/u32::Organize as OrganizeU32

/**
Convert stream of `Vec<f32>` into `Vec<u32>` one.

`Vec<f32>` gets converted into `Vec<u32>`, and the resulting vectors are send through stream in continuity.

Every `f32` is truncated to fit into the `u32`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f32` is a positive infinity,
- `neg_infinity` is used when `f32` is a negative infinity,
- `nan` is used when `f32` is not a number.
*/
sequence ToU32(var pos_infinity: u32 = 4294967295, var neg_infinity: u32 = 0, var nan: u32 = 0)
  input  value: Stream<Vec<f32>>
  output value: Stream<Vec<u32>>
{
    ToVoid()
    Linearize()
    ScalToU32(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)
    OrganizeU32()

    Self.value -> Linearize.vector,value -> ScalToU32.value,value -> OrganizeU32.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern -----------------------------> OrganizeU32.pattern
}

use std/conversion/scalar/f32::ToU64 as ScalToU64
use std/flow/u64::Organize as OrganizeU64

/**
Convert stream of `Vec<f32>` into `Vec<u64>` one.

`Vec<f32>` gets converted into `Vec<u64>`, and the resulting vectors are send through stream in continuity.

Every `f32` is truncated to fit into the `u64`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f32` is a positive infinity,
- `neg_infinity` is used when `f32` is a negative infinity,
- `nan` is used when `f32` is not a number.
*/
sequence ToU64(var pos_infinity: u64 = 18446744073709551615, var neg_infinity: u64 = 0, var nan: u64 = 0)
  input  value: Stream<Vec<f32>>
  output value: Stream<Vec<u64>>
{
    ToVoid()
    Linearize()
    ScalToU64(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)
    OrganizeU64()

    Self.value -> Linearize.vector,value -> ScalToU64.value,value -> OrganizeU64.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern -----------------------------> OrganizeU64.pattern
}

use std/conversion/scalar/f32::ToU128 as ScalToU128
use std/flow/u128::Organize as OrganizeU128

/**
Convert stream of `Vec<f32>` into `Vec<u128>` one.

`Vec<f32>` gets converted into `Vec<u128>`, and the resulting vectors are send through stream in continuity.

Every `f32` is truncated to fit into the `u128`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f32` is a positive infinity,
- `neg_infinity` is used when `f32` is a negative infinity,
- `nan` is used when `f32` is not a number.
*/
sequence ToU128(var pos_infinity: u128 = 340282366920938463463374607431768211455, var neg_infinity: u128 = 0, var nan: u128 = 0)
  input  value: Stream<Vec<f32>>
  output value: Stream<Vec<u128>>
{
    ToVoid()
    Linearize()
    ScalToU128(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)
    OrganizeU128()

    Self.value -> Linearize.vector,value -> ScalToU128.value,value -> OrganizeU128.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern -----------------------------> OrganizeU128.pattern
}

use std/conversion/scalar/f32::ToI8 as ScalToI8
use std/flow/i8::Organize as OrganizeI8

/**
Convert stream of `Vec<f32>` into `Vec<i8>` one.

`Vec<f32>` gets converted into `Vec<i8>`, and the resulting vectors are send through stream in continuity.

Every `f32` is truncated to fit into the `i8`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f32` is a positive infinity,
- `neg_infinity` is used when `f32` is a negative infinity,
- `nan` is used when `f32` is not a number.
*/
sequence ToI8(var pos_infinity: i8 = 127, var neg_infinity: i8 = -128, var nan: i8 = 0)
  input  value: Stream<Vec<f32>>
  output value: Stream<Vec<i8>>
{
    ToVoid()
    Linearize()
    ScalToI8(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)
    OrganizeI8()

    Self.value -> Linearize.vector,value -> ScalToI8.value,value -> OrganizeI8.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern -----------------------------> OrganizeI8.pattern
}

use std/conversion/scalar/f32::ToI16 as ScalToI16
use std/flow/i16::Organize as OrganizeI16

/**
Convert stream of `Vec<f32>` into `Vec<i16>` one.

`Vec<f32>` gets converted into `Vec<i16>`, and the resulting vectors are send through stream in continuity.

Every `f32` is truncated to fit into the `i16`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f32` is a positive infinity,
- `neg_infinity` is used when `f32` is a negative infinity,
- `nan` is used when `f32` is not a number.
*/
sequence ToI16(var pos_infinity: i16 = 32767, var neg_infinity: i16 = -32768, var nan: i16 = 0)
  input  value: Stream<Vec<f32>>
  output value: Stream<Vec<i16>>
{
    ToVoid()
    Linearize()
    ScalToI16(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)
    OrganizeI16()

    Self.value -> Linearize.vector,value -> ScalToI16.value,value -> OrganizeI16.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern -----------------------------> OrganizeI16.pattern
}

use std/conversion/scalar/f32::ToI32 as ScalToI32
use std/flow/i32::Organize as OrganizeI32

/**
Convert stream of `Vec<f32>` into `Vec<i32>` one.

`Vec<f32>` gets converted into `Vec<i32>`, and the resulting vectors are send through stream in continuity.

Every `f32` is truncated to fit into the `i32`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f32` is a positive infinity,
- `neg_infinity` is used when `f32` is a negative infinity,
- `nan` is used when `f32` is not a number.
*/
sequence ToI32(var pos_infinity: i32 = 2147483647, var neg_infinity: i32 = -2147483648, var nan: i32 = 0)
  input  value: Stream<Vec<f32>>
  output value: Stream<Vec<i32>>
{
    ToVoid()
    Linearize()
    ScalToI32(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)
    OrganizeI32()

    Self.value -> Linearize.vector,value -> ScalToI32.value,value -> OrganizeI32.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern -----------------------------> OrganizeI32.pattern
}

use std/conversion/scalar/f32::ToI64 as ScalToI64
use std/flow/i64::Organize as OrganizeI64

/**
Convert stream of `Vec<f32>` into `Vec<i64>` one.

`Vec<f32>` gets converted into `Vec<i64>`, and the resulting vectors are send through stream in continuity.

Every `f32` is truncated to fit into the `i64`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f32` is a positive infinity,
- `neg_infinity` is used when `f32` is a negative infinity,
- `nan` is used when `f32` is not a number.
*/
sequence ToI64(var pos_infinity: i64 = 9223372036854775807, var neg_infinity: i64 = -9223372036854775808, var nan: i64 = 0)
  input  value: Stream<Vec<f32>>
  output value: Stream<Vec<i64>>
{
    ToVoid()
    Linearize()
    ScalToI64(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)
    OrganizeI64()

    Self.value -> Linearize.vector,value -> ScalToI64.value,value -> OrganizeI64.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern -----------------------------> OrganizeI64.pattern
}

use std/conversion/scalar/f32::ToI128 as ScalToI128
use std/flow/i128::Organize as OrganizeI128

/**
Convert stream of `Vec<f32>` into `Vec<i128>` one.

`Vec<f32>` gets converted into `Vec<i128>`, and the resulting vectors are send through stream in continuity.

Every `f32` is truncated to fit into the `i128`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f32` is a positive infinity,
- `neg_infinity` is used when `f32` is a negative infinity,
- `nan` is used when `f32` is not a number.
*/
sequence ToI128(var pos_infinity: i128 = 170141183460469231731687303715884105727, var neg_infinity: i128 = -170141183460469231731687303715884105728, var nan: i128 = 0)
  input  value: Stream<Vec<f32>>
  output value: Stream<Vec<i128>>
{
    ToVoid()
    Linearize()
    ScalToI128(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)
    OrganizeI128()

    Self.value -> Linearize.vector,value -> ScalToI128.value,value -> OrganizeI128.value,values -> Self.data
    Self.value -> ToVoid.vector,pattern -----------------------------> OrganizeI128.pattern
}

