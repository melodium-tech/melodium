
use core/cast/scalar::U8ToI128 as CoreU8ToI128

/**
Convert stream of `u8` into `i128`.

This conversion is lossless, `u8` values can always fit into `i128` ones.
*/
sequence U8ToI128()
  input  value: Stream<u8>
  output value: Stream<i128>
{
    CoreU8ToI128()

    Self.value -> CoreU8ToI128.value,value -> Self.value
}



use core/cast/scalar::U16ToI128 as CoreU16ToI128

/**
Convert stream of `u16` into `i128`.

This conversion is lossless, `u16` values can always fit into `i128` ones.
*/
sequence U16ToI128()
  input  value: Stream<u16>
  output value: Stream<i128>
{
    CoreU16ToI128()

    Self.value -> CoreU16ToI128.value,value -> Self.value
}



use core/cast/scalar::U32ToI128 as CoreU32ToI128

/**
Convert stream of `u32` into `i128`.

This conversion is lossless, `u32` values can always fit into `i128` ones.
*/
sequence U32ToI128()
  input  value: Stream<u32>
  output value: Stream<i128>
{
    CoreU32ToI128()

    Self.value -> CoreU32ToI128.value,value -> Self.value
}



use core/cast/scalar::U64ToI128 as CoreU64ToI128

/**
Convert stream of `u64` into `i128`.

This conversion is lossless, `u64` values can always fit into `i128` ones.
*/
sequence U64ToI128()
  input  value: Stream<u64>
  output value: Stream<i128>
{
    CoreU64ToI128()

    Self.value -> CoreU64ToI128.value,value -> Self.value
}



use core/cast/scalar::I8ToI128 as CoreI8ToI128

/**
Convert stream of `i8` into `i128`.

This conversion is lossless, `i8` values can always fit into `i128` ones.
*/
sequence I8ToI128()
  input  value: Stream<i8>
  output value: Stream<i128>
{
    CoreI8ToI128()

    Self.value -> CoreI8ToI128.value,value -> Self.value
}



use core/cast/scalar::I16ToI128 as CoreI16ToI128

/**
Convert stream of `i16` into `i128`.

This conversion is lossless, `i16` values can always fit into `i128` ones.
*/
sequence I16ToI128()
  input  value: Stream<i16>
  output value: Stream<i128>
{
    CoreI16ToI128()

    Self.value -> CoreI16ToI128.value,value -> Self.value
}



use core/cast/scalar::I32ToI128 as CoreI32ToI128

/**
Convert stream of `i32` into `i128`.

This conversion is lossless, `i32` values can always fit into `i128` ones.
*/
sequence I32ToI128()
  input  value: Stream<i32>
  output value: Stream<i128>
{
    CoreI32ToI128()

    Self.value -> CoreI32ToI128.value,value -> Self.value
}



use core/cast/scalar::I64ToI128 as CoreI64ToI128

/**
Convert stream of `i64` into `i128`.

This conversion is lossless, `i64` values can always fit into `i128` ones.
*/
sequence I64ToI128()
  input  value: Stream<i64>
  output value: Stream<i128>
{
    CoreI64ToI128()

    Self.value -> CoreI64ToI128.value,value -> Self.value
}



use core/cast/scalar::CastScalarU128ToI128 as CoreCastScalarU128ToI128 

/**
Convert stream of `u128` into `i128`.

As this conversion might be lossy (every possible `u128` value cannot fit into `i128`),
`truncate` allows value to be truncated to fit into a `i128`, and `or_default` set the
value that is assigned when a `u128` is out of range for `i128` and truncation not allowed.
*/
sequence U128ToI128(var truncate: bool = true, var or_default: i128 = 0)
  input  value: Stream<u128>
  output value: Stream<i128>
{
    CoreCastScalarU128ToI128()

    Self.value -> CoreCastScalarU128ToI128.value,value -> Self.value
}



use core/conversion/scalar::ScalarF32ToI128 as CoreScalarF32ToI128 

/**
Convert stream of `f32` into `i128`.

Every `f32` is truncated to fit into the `i128`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f32` is a positive infinity,
- `neg_infinity` is used when `f32` is a negative infinity,
- `nan` is used when `f32` is not a number.
*/
sequence F32ToI128(var pos_infinity: i128 = 170141183460469231731687303715884105727, var neg_infinity: i128 = -170141183460469231731687303715884105728, var nan: i128 = 0)
  input  value: Stream<f32>
  output value: Stream<i128>
{
    CoreScalarF32ToI128(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)

    Self.value -> CoreScalarF32ToI128.value,value -> Self.value
}



use core/conversion/scalar::ScalarF64ToI128 as CoreScalarF64ToI128 

/**
Convert stream of `f64` into `i128`.

Every `f64` is truncated to fit into the `i128`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f64` is a positive infinity,
- `neg_infinity` is used when `f64` is a negative infinity,
- `nan` is used when `f64` is not a number.
*/
sequence F64ToI128(var pos_infinity: i128 = 170141183460469231731687303715884105727, var neg_infinity: i128 = -170141183460469231731687303715884105728, var nan: i128 = 0)
  input  value: Stream<f64>
  output value: Stream<i128>
{
    CoreScalarF64ToI128(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)

    Self.value -> CoreScalarF64ToI128.value,value -> Self.value
}


