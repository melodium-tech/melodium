
use core/cast/scalar::U8ToU128 as CoreU8ToU128

/**
Convert stream of `u8` into `u128`.

This conversion is lossless, `u8` values can always fit into `u128` ones.
*/
sequence U8ToU128()
  input  value: Stream<u8>
  output value: Stream<u128>
{
    CoreU8ToU128()

    Self.value -> CoreU8ToU128.value,value -> Self.value
}



use core/cast/scalar::U16ToU128 as CoreU16ToU128

/**
Convert stream of `u16` into `u128`.

This conversion is lossless, `u16` values can always fit into `u128` ones.
*/
sequence U16ToU128()
  input  value: Stream<u16>
  output value: Stream<u128>
{
    CoreU16ToU128()

    Self.value -> CoreU16ToU128.value,value -> Self.value
}



use core/cast/scalar::U32ToU128 as CoreU32ToU128

/**
Convert stream of `u32` into `u128`.

This conversion is lossless, `u32` values can always fit into `u128` ones.
*/
sequence U32ToU128()
  input  value: Stream<u32>
  output value: Stream<u128>
{
    CoreU32ToU128()

    Self.value -> CoreU32ToU128.value,value -> Self.value
}



use core/cast/scalar::U64ToU128 as CoreU64ToU128

/**
Convert stream of `u64` into `u128`.

This conversion is lossless, `u64` values can always fit into `u128` ones.
*/
sequence U64ToU128()
  input  value: Stream<u64>
  output value: Stream<u128>
{
    CoreU64ToU128()

    Self.value -> CoreU64ToU128.value,value -> Self.value
}



use core/cast/scalar::CastScalarI8ToU128 as CoreCastScalarI8ToU128 

/**
Convert stream of `i8` into `u128`.

As this conversion might be lossy (every possible `i8` value cannot fit into `u128`),
`truncate` allows value to be truncated to fit into a `u128`, and `or_default` set the
value that is assigned when a `i8` is out of range for `u128` and truncation not allowed.
*/
sequence I8ToU128(var truncate: bool = true, var or_default: u128 = 0)
  input  value: Stream<i8>
  output value: Stream<u128>
{
    CoreCastScalarI8ToU128()

    Self.value -> CoreCastScalarI8ToU128.value,value -> Self.value
}



use core/cast/scalar::CastScalarI16ToU128 as CoreCastScalarI16ToU128 

/**
Convert stream of `i16` into `u128`.

As this conversion might be lossy (every possible `i16` value cannot fit into `u128`),
`truncate` allows value to be truncated to fit into a `u128`, and `or_default` set the
value that is assigned when a `i16` is out of range for `u128` and truncation not allowed.
*/
sequence I16ToU128(var truncate: bool = true, var or_default: u128 = 0)
  input  value: Stream<i16>
  output value: Stream<u128>
{
    CoreCastScalarI16ToU128()

    Self.value -> CoreCastScalarI16ToU128.value,value -> Self.value
}



use core/cast/scalar::CastScalarI32ToU128 as CoreCastScalarI32ToU128 

/**
Convert stream of `i32` into `u128`.

As this conversion might be lossy (every possible `i32` value cannot fit into `u128`),
`truncate` allows value to be truncated to fit into a `u128`, and `or_default` set the
value that is assigned when a `i32` is out of range for `u128` and truncation not allowed.
*/
sequence I32ToU128(var truncate: bool = true, var or_default: u128 = 0)
  input  value: Stream<i32>
  output value: Stream<u128>
{
    CoreCastScalarI32ToU128()

    Self.value -> CoreCastScalarI32ToU128.value,value -> Self.value
}



use core/cast/scalar::CastScalarI64ToU128 as CoreCastScalarI64ToU128 

/**
Convert stream of `i64` into `u128`.

As this conversion might be lossy (every possible `i64` value cannot fit into `u128`),
`truncate` allows value to be truncated to fit into a `u128`, and `or_default` set the
value that is assigned when a `i64` is out of range for `u128` and truncation not allowed.
*/
sequence I64ToU128(var truncate: bool = true, var or_default: u128 = 0)
  input  value: Stream<i64>
  output value: Stream<u128>
{
    CoreCastScalarI64ToU128()

    Self.value -> CoreCastScalarI64ToU128.value,value -> Self.value
}



use core/cast/scalar::CastScalarI128ToU128 as CoreCastScalarI128ToU128 

/**
Convert stream of `i128` into `u128`.

As this conversion might be lossy (every possible `i128` value cannot fit into `u128`),
`truncate` allows value to be truncated to fit into a `u128`, and `or_default` set the
value that is assigned when a `i128` is out of range for `u128` and truncation not allowed.
*/
sequence I128ToU128(var truncate: bool = true, var or_default: u128 = 0)
  input  value: Stream<i128>
  output value: Stream<u128>
{
    CoreCastScalarI128ToU128()

    Self.value -> CoreCastScalarI128ToU128.value,value -> Self.value
}



use core/conversion/scalar::ScalarF32ToU128 as CoreScalarF32ToU128 

/**
Convert stream of `f32` into `u128`.

Every `f32` is truncated to fit into the `u128`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f32` is a positive infinity,
- `neg_infinity` is used when `f32` is a negative infinity,
- `nan` is used when `f32` is not a number.
*/
sequence F32ToU128(var pos_infinity: u128 = 340282366920938463463374607431768211455, var neg_infinity: u128 = 0, var nan: u128 = 0)
  input  value: Stream<f32>
  output value: Stream<u128>
{
    CoreScalarF32ToU128(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)

    Self.value -> CoreScalarF32ToU128.value,value -> Self.value
}



use core/conversion/scalar::ScalarF64ToU128 as CoreScalarF64ToU128 

/**
Convert stream of `f64` into `u128`.

Every `f64` is truncated to fit into the `u128`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f64` is a positive infinity,
- `neg_infinity` is used when `f64` is a negative infinity,
- `nan` is used when `f64` is not a number.
*/
sequence F64ToU128(var pos_infinity: u128 = 340282366920938463463374607431768211455, var neg_infinity: u128 = 0, var nan: u128 = 0)
  input  value: Stream<f64>
  output value: Stream<u128>
{
    CoreScalarF64ToU128(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)

    Self.value -> CoreScalarF64ToU128.value,value -> Self.value
}


