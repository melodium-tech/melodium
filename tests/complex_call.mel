#!/usr/bin/env melodium
#! name = fs_test
#! version = 0.7.1
#! require = flow:0.7.1
#! require = engine:0.7.1
#! require = conv:0.7.1
#! require = fs:0.7.1
#! require = ops:0.7.1

use engine/util::startup
use flow::generate
use flow::emit
use flow::fill
use flow::count
use flow::stream
use flow::trigger
use fs/file::write
use conv/u128::toByte
use flow/vec::flatten
use ops/u128::|add

treatment main(const content: string = "this is some text", var generate: u128 = 873, const output: string = "./output_count") {
    startup()
    generate_arbitrary(length = |add(generate, 3), text = content)
    count_writer(output_file = output)

    startup.trigger -> generate_arbitrary.trigger,generated -> count_writer.text
}

treatment generate_arbitrary(var length: u128, const text: string)
  input trigger: Block<void>
  output generated: Stream<string>
{
    effective_generator(size = length)
    converter(content = text)

    Self.trigger -> effective_generator.trigger,data -> converter.stream,text -> Self.generated
}

treatment effective_generator(var size: u128)
  input trigger: Block<void>
  output data: Stream<void>
{
    generate<void>(data=_)
    emit<u128>(value=size)

    Self.trigger -> emit.trigger,emit -> generate.length,stream -> Self.data 
}

treatment converter(var content: string)
  input stream: Stream<void>
  output text: Stream<string>
{
    fill<string>(value=content)

    Self.stream -> fill.pattern,filled -> Self.text
}

treatment count_writer(var output_file: string)
    input text: Stream<string>
{
    count<string>()
    trigger<u128>()
    stream<u128>()
    write()
    emit<string>(value=output_file)
    toByte()
    flatten<byte>()

    Self.text -> count.stream,count -> trigger.stream,last -> stream.block,stream -> toByte.value,data -> flatten.vector,value -> write.data
    trigger.end -> emit.trigger,emit -> write.path
}

