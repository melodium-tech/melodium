
use core/cast/scalar::CastScalarU16ToU8 as CoreCastScalarU16ToU8 

/**
Convert stream of `u16` into `u8`.

As this conversion might be lossy (every possible `u16` value cannot fit into `u8`),
`truncate` allows value to be truncated to fit into a `u8`, and `or_default` set the
value that is assigned when a `u16` is out of range for `u8` and truncation not allowed.
*/
sequence U16ToU8(var truncate: bool = true, var or_default: u8 = 0)
  input  value: Stream<u16>
  output value: Stream<u8>
{
    CoreCastScalarU16ToU8()

    Self.value -> CoreCastScalarU16ToU8.value,value -> Self.value
}



use core/cast/scalar::CastScalarU32ToU8 as CoreCastScalarU32ToU8 

/**
Convert stream of `u32` into `u8`.

As this conversion might be lossy (every possible `u32` value cannot fit into `u8`),
`truncate` allows value to be truncated to fit into a `u8`, and `or_default` set the
value that is assigned when a `u32` is out of range for `u8` and truncation not allowed.
*/
sequence U32ToU8(var truncate: bool = true, var or_default: u8 = 0)
  input  value: Stream<u32>
  output value: Stream<u8>
{
    CoreCastScalarU32ToU8()

    Self.value -> CoreCastScalarU32ToU8.value,value -> Self.value
}



use core/cast/scalar::CastScalarU64ToU8 as CoreCastScalarU64ToU8 

/**
Convert stream of `u64` into `u8`.

As this conversion might be lossy (every possible `u64` value cannot fit into `u8`),
`truncate` allows value to be truncated to fit into a `u8`, and `or_default` set the
value that is assigned when a `u64` is out of range for `u8` and truncation not allowed.
*/
sequence U64ToU8(var truncate: bool = true, var or_default: u8 = 0)
  input  value: Stream<u64>
  output value: Stream<u8>
{
    CoreCastScalarU64ToU8()

    Self.value -> CoreCastScalarU64ToU8.value,value -> Self.value
}



use core/cast/scalar::CastScalarU128ToU8 as CoreCastScalarU128ToU8 

/**
Convert stream of `u128` into `u8`.

As this conversion might be lossy (every possible `u128` value cannot fit into `u8`),
`truncate` allows value to be truncated to fit into a `u8`, and `or_default` set the
value that is assigned when a `u128` is out of range for `u8` and truncation not allowed.
*/
sequence U128ToU8(var truncate: bool = true, var or_default: u8 = 0)
  input  value: Stream<u128>
  output value: Stream<u8>
{
    CoreCastScalarU128ToU8()

    Self.value -> CoreCastScalarU128ToU8.value,value -> Self.value
}



use core/cast/scalar::CastScalarI8ToU8 as CoreCastScalarI8ToU8 

/**
Convert stream of `i8` into `u8`.

As this conversion might be lossy (every possible `i8` value cannot fit into `u8`),
`truncate` allows value to be truncated to fit into a `u8`, and `or_default` set the
value that is assigned when a `i8` is out of range for `u8` and truncation not allowed.
*/
sequence I8ToU8(var truncate: bool = true, var or_default: u8 = 0)
  input  value: Stream<i8>
  output value: Stream<u8>
{
    CoreCastScalarI8ToU8()

    Self.value -> CoreCastScalarI8ToU8.value,value -> Self.value
}



use core/cast/scalar::CastScalarI16ToU8 as CoreCastScalarI16ToU8 

/**
Convert stream of `i16` into `u8`.

As this conversion might be lossy (every possible `i16` value cannot fit into `u8`),
`truncate` allows value to be truncated to fit into a `u8`, and `or_default` set the
value that is assigned when a `i16` is out of range for `u8` and truncation not allowed.
*/
sequence I16ToU8(var truncate: bool = true, var or_default: u8 = 0)
  input  value: Stream<i16>
  output value: Stream<u8>
{
    CoreCastScalarI16ToU8()

    Self.value -> CoreCastScalarI16ToU8.value,value -> Self.value
}



use core/cast/scalar::CastScalarI32ToU8 as CoreCastScalarI32ToU8 

/**
Convert stream of `i32` into `u8`.

As this conversion might be lossy (every possible `i32` value cannot fit into `u8`),
`truncate` allows value to be truncated to fit into a `u8`, and `or_default` set the
value that is assigned when a `i32` is out of range for `u8` and truncation not allowed.
*/
sequence I32ToU8(var truncate: bool = true, var or_default: u8 = 0)
  input  value: Stream<i32>
  output value: Stream<u8>
{
    CoreCastScalarI32ToU8()

    Self.value -> CoreCastScalarI32ToU8.value,value -> Self.value
}



use core/cast/scalar::CastScalarI64ToU8 as CoreCastScalarI64ToU8 

/**
Convert stream of `i64` into `u8`.

As this conversion might be lossy (every possible `i64` value cannot fit into `u8`),
`truncate` allows value to be truncated to fit into a `u8`, and `or_default` set the
value that is assigned when a `i64` is out of range for `u8` and truncation not allowed.
*/
sequence I64ToU8(var truncate: bool = true, var or_default: u8 = 0)
  input  value: Stream<i64>
  output value: Stream<u8>
{
    CoreCastScalarI64ToU8()

    Self.value -> CoreCastScalarI64ToU8.value,value -> Self.value
}



use core/cast/scalar::CastScalarI128ToU8 as CoreCastScalarI128ToU8 

/**
Convert stream of `i128` into `u8`.

As this conversion might be lossy (every possible `i128` value cannot fit into `u8`),
`truncate` allows value to be truncated to fit into a `u8`, and `or_default` set the
value that is assigned when a `i128` is out of range for `u8` and truncation not allowed.
*/
sequence I128ToU8(var truncate: bool = true, var or_default: u8 = 0)
  input  value: Stream<i128>
  output value: Stream<u8>
{
    CoreCastScalarI128ToU8()

    Self.value -> CoreCastScalarI128ToU8.value,value -> Self.value
}



use core/conversion/scalar::ScalarF32ToU8 as CoreScalarF32ToU8 

/**
Convert stream of `f32` into `u8`.

Every `f32` is truncated to fit into the `u8`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f32` is a positive infinity,
- `neg_infinity` is used when `f32` is a negative infinity,
- `nan` is used when `f32` is not a number.
*/
sequence F32ToU8(var pos_infinity: u8 = 255, var neg_infinity: u8 = 0, var nan: u8 = 0)
  input  value: Stream<f32>
  output value: Stream<u8>
{
    CoreScalarF32ToU8(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)

    Self.value -> CoreScalarF32ToU8.value,value -> Self.value
}



use core/conversion/scalar::ScalarF64ToU8 as CoreScalarF64ToU8 

/**
Convert stream of `f64` into `u8`.

Every `f64` is truncated to fit into the `u8`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f64` is a positive infinity,
- `neg_infinity` is used when `f64` is a negative infinity,
- `nan` is used when `f64` is not a number.
*/
sequence F64ToU8(var pos_infinity: u8 = 255, var neg_infinity: u8 = 0, var nan: u8 = 0)
  input  value: Stream<f64>
  output value: Stream<u8>
{
    CoreScalarF64ToU8(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)

    Self.value -> CoreScalarF64ToU8.value,value -> Self.value
}


