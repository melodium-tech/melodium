
use core/cast/scalar::U8ToF32 as CoreU8ToF32

/**
Convert stream of `u8` into `f32`.

This conversion is lossless, `u8` values can always fit into `f32` ones.
*/
sequence U8ToF32()
  input  value: Stream<u8>
  output value: Stream<f32>
{
    CoreU8ToF32()

    Self.value -> CoreU8ToF32.value,value -> Self.value
}



use core/cast/scalar::U16ToF32 as CoreU16ToF32

/**
Convert stream of `u16` into `f32`.

This conversion is lossless, `u16` values can always fit into `f32` ones.
*/
sequence U16ToF32()
  input  value: Stream<u16>
  output value: Stream<f32>
{
    CoreU16ToF32()

    Self.value -> CoreU16ToF32.value,value -> Self.value
}



use core/cast/scalar::U32ToF32 as CoreU32ToF32

/**
Convert stream of `u32` into `f32`.

This conversion is lossless, `u32` values can always fit into `f32` ones.
*/
sequence U32ToF32()
  input  value: Stream<u32>
  output value: Stream<f32>
{
    CoreU32ToF32()

    Self.value -> CoreU32ToF32.value,value -> Self.value
}



use core/cast/scalar::U64ToF32 as CoreU64ToF32

/**
Convert stream of `u64` into `f32`.

This conversion is lossless, `u64` values can always fit into `f32` ones.
*/
sequence U64ToF32()
  input  value: Stream<u64>
  output value: Stream<f32>
{
    CoreU64ToF32()

    Self.value -> CoreU64ToF32.value,value -> Self.value
}



use core/cast/scalar::U128ToF32 as CoreU128ToF32

/**
Convert stream of `u128` into `f32`.

This conversion is lossless, `u128` values can always fit into `f32` ones.
*/
sequence U128ToF32()
  input  value: Stream<u128>
  output value: Stream<f32>
{
    CoreU128ToF32()

    Self.value -> CoreU128ToF32.value,value -> Self.value
}



use core/cast/scalar::I8ToF32 as CoreI8ToF32

/**
Convert stream of `i8` into `f32`.

This conversion is lossless, `i8` values can always fit into `f32` ones.
*/
sequence I8ToF32()
  input  value: Stream<i8>
  output value: Stream<f32>
{
    CoreI8ToF32()

    Self.value -> CoreI8ToF32.value,value -> Self.value
}



use core/cast/scalar::I16ToF32 as CoreI16ToF32

/**
Convert stream of `i16` into `f32`.

This conversion is lossless, `i16` values can always fit into `f32` ones.
*/
sequence I16ToF32()
  input  value: Stream<i16>
  output value: Stream<f32>
{
    CoreI16ToF32()

    Self.value -> CoreI16ToF32.value,value -> Self.value
}



use core/cast/scalar::I32ToF32 as CoreI32ToF32

/**
Convert stream of `i32` into `f32`.

This conversion is lossless, `i32` values can always fit into `f32` ones.
*/
sequence I32ToF32()
  input  value: Stream<i32>
  output value: Stream<f32>
{
    CoreI32ToF32()

    Self.value -> CoreI32ToF32.value,value -> Self.value
}



use core/cast/scalar::I64ToF32 as CoreI64ToF32

/**
Convert stream of `i64` into `f32`.

This conversion is lossless, `i64` values can always fit into `f32` ones.
*/
sequence I64ToF32()
  input  value: Stream<i64>
  output value: Stream<f32>
{
    CoreI64ToF32()

    Self.value -> CoreI64ToF32.value,value -> Self.value
}



use core/cast/scalar::I128ToF32 as CoreI128ToF32

/**
Convert stream of `i128` into `f32`.

This conversion is lossless, `i128` values can always fit into `f32` ones.
*/
sequence I128ToF32()
  input  value: Stream<i128>
  output value: Stream<f32>
{
    CoreI128ToF32()

    Self.value -> CoreI128ToF32.value,value -> Self.value
}


