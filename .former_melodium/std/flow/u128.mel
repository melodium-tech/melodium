use core/linearize::LinearizeU128

/**
Linearize stream of `Vec<u128>` into stream of `Scalar<u128>`.

All the input vectors are turned into continuous stream of scalar values, in the same order.
```mermaid
graph LR
    T(Linearize)
    B["ï¼»ğŸŸ¦Â ğŸŸ¦ï¼½ï¼»ğŸŸ¦ï¼½ï¼»ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦ï¼½"] -->|vector| T
    
    T -->|value| O["ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦"]

    style B fill:#ffff,stroke:#ffff
    style O fill:#ffff,stroke:#ffff
```
*/
sequence Linearize()
  input vector: Stream<Vec<u128>>
  output value: Stream<u128>
{
    LinearizeU128()

    Self.vector -> LinearizeU128.vector,value -> Self.value
}


use core/flow::StreamU128ToBlockVecU128

/**
Transform whole stream of `u128` into a single vector block.

All the streamed values are added to a single vector, and once stream is over the vector is transmitted.

```mermaid
graph LR
    T(BlockAllStream)
    B["ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦"] -->|stream| T
    
    T -->|block| O["ã€ˆï¼»ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦ï¼½ã€‰"]

    style B fill:#ffff,stroke:#ffff
    style O fill:#ffff,stroke:#ffff
```

âš ï¸ As the stream values are continuously inserted in vector and so kept in memory, user should be _really careful_ when using this treatment to not saturate memory.

*/
sequence BlockAllStream()
  input  stream: Stream<u128>
  output block:  Block<Vec<u128>>
{
    StreamU128ToBlockVecU128()

    Self.stream -> StreamU128ToBlockVecU128.data,data -> Self.block
}


use core/flow::BlockU128ToStream

/**
Stream a block of `u128`.

The received block is sent as streamed value, then the stream is closed.

```mermaid
graph LR
    T(StreamBlock)
    B["ã€ˆğŸŸ¦ã€‰"] -->|block| T
    
    T -->|stream| O["ğŸŸ¦"]

    style B fill:#ffff,stroke:#ffff
    style O fill:#ffff,stroke:#ffff
```
*/
sequence StreamBlock()
  input  block:  Block<u128>
  output stream: Stream<u128>
{
    BlockU128ToStream()

    Self.block -> BlockU128ToStream.data,data -> Self.stream
}


use core/flow::BlockVecU128ToStream

/**
Stream a vector of `u128`.

The received block is sent as streamed vector, then the stream is closed.

```mermaid
graph LR
    T(StreamVecBlock)
    B["ã€ˆï¼»ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦ï¼½ã€‰"] -->|block| T
    
    T -->|stream| O["ï¼»ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦ï¼½"]

    style B fill:#ffff,stroke:#ffff
    style O fill:#ffff,stroke:#ffff
```
*/
sequence StreamVecBlock()
  input  block:  Block<Vec<u128>>
  output stream: Stream<Vec<u128>>
{
    BlockVecU128ToStream()

    Self.block -> BlockVecU128ToStream.data,data -> Self.stream
}


use core/merge/scalar/u128::Merge as CoreMerge

/**
Merge two streams of `u128`.

The two streams are merged using the `order` stream:
- when `true`, value from `a` is used;
- when `false`, value from `b` is used.

â„¹ï¸ No value from either `a` or `b` are discarded, they are used when `order` give turn.

âš ï¸ When `order` ends merge terminates without treating the remaining values from `a` and `b`.
When `order` give turn to `a` or `b` while the concerned stream is ended, the merge terminates.
Merge continues as long as `order` and concerned stream does, while the other can be ended.

```mermaid
graph LR
    T("Merge()")
    A["â€¦Â ğŸŸ¦ ğŸŸ«Â â€¦"] -->|a| T
    B["â€¦Â ğŸŸ§Â ğŸŸª ğŸŸ¨Â â€¦"] -->|b| T
    O["â€¦Â ğŸŸ©Â ğŸŸ¥Â ğŸŸ¥Â ğŸŸ©Â ğŸŸ¥Â â€¦"] -->|order|T
    

    T -->|value| V["â€¦Â ğŸŸ¦Â ğŸŸ§Â ğŸŸªÂ ğŸŸ«Â ğŸŸ¨Â â€¦"]

    style V fill:#ffff,stroke:#ffff
    style O fill:#ffff,stroke:#ffff
    style A fill:#ffff,stroke:#ffff
    style B fill:#ffff,stroke:#ffff
```
*/
sequence Merge()
  input  a:     Stream<u128>
  input  b:     Stream<u128>
  input  order: Stream<bool>
  output value: Stream<u128>
{
    CoreMerge()

    Self.a -> CoreMerge.a
    Self.b -> CoreMerge.b
    Self.order -> CoreMerge.order,value -> Self.value
}


use core/merge/vector/u128::Merge as CoreVecMerge

/**
Merge two streams of `Vec<u128>`.

The two streams are merged using the `order` stream:
- when `true`, value from `a` is used;
- when `false`, value from `b` is used.

â„¹ï¸ No value from either `a` or `b` are discarded, they are used when `order` give turn.

âš ï¸ When `order` ends merge terminates without treating the remaining values from `a` and `b`.
When `order` give turn to `a` or `b` while the concerned stream is ended, the merge terminates.
Merge continues as long as `order` and concerned stream does, while the other can be ended.

```mermaid
graph LR
    T("VecMerge()")
    A["â€¦Â ï¼»ğŸŸ¦Â ğŸŸ¦ï¼½ï¼»ğŸŸ«Â ğŸŸ«ï¼½â€¦"] -->|a| T
    B["â€¦Â ï¼»ğŸŸ§Â ğŸŸ§Â ğŸŸ§ï¼½ï¼»ğŸŸªï¼½ï¼»ğŸŸ¨Â ğŸŸ¨ï¼½â€¦"] -->|b| T
    O["â€¦Â ğŸŸ©Â ğŸŸ¥Â ğŸŸ¥Â ğŸŸ©Â ğŸŸ¥Â â€¦"] -->|order|T
    

    T -->|value| V["â€¦ï¼»ğŸŸ¦Â ğŸŸ¦ï¼½ï¼»ğŸŸ§Â ğŸŸ§Â ğŸŸ§ï¼½ï¼»ğŸŸªï¼½ï¼»ğŸŸ«Â ğŸŸ«ï¼½ï¼»ğŸŸ¨Â ğŸŸ¨ï¼½â€¦"]

    style V fill:#ffff,stroke:#ffff
    style O fill:#ffff,stroke:#ffff
    style A fill:#ffff,stroke:#ffff
    style B fill:#ffff,stroke:#ffff
```
*/
sequence VecMerge()
  input  a:     Stream<Vec<u128>>
  input  b:     Stream<Vec<u128>>
  input  order: Stream<bool>
  output value: Stream<Vec<u128>>
{
    CoreVecMerge()

    Self.a -> CoreVecMerge.a
    Self.b -> CoreVecMerge.b
    Self.order -> CoreVecMerge.order,value -> Self.value
}

use core/organize::OrganizeU128

/**
Organize stream of `u128` into stream of `Vec<u128>`.

â„¹ï¸ If some remaining values doesn't fit into the pattern, they are trashed.
If there are not enough values to fit the pattern, uncomplete vector is trashed.

```mermaid
graph LR
    T(Organize)
    A["â€¦ ğŸŸ¨Â ğŸŸ¨Â ğŸŸ¨Â ğŸŸ¨Â ğŸŸ¨Â ğŸŸ¨"] -->|value| T
    B["[ğŸŸ¦Â ğŸŸ¦]Â [ğŸŸ¦]Â [ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦]"] -->|pattern| T
    
    T -->|values| O["[ğŸŸ¨Â ğŸŸ¨]Â [ğŸŸ¨]Â [ğŸŸ¨Â ğŸŸ¨Â ğŸŸ¨]"]

    style A fill:#ffff,stroke:#ffff
    style B fill:#ffff,stroke:#ffff
    style O fill:#ffff,stroke:#ffff
```

*/
sequence Organize()
  input   value: Stream<u128>
  input pattern: Stream<Vec<void>>
  output values: Stream<Vec<u128>>
{
    OrganizeU128()

    Self.value ---> OrganizeU128.value,values -> Self.values
    Self.pattern -> OrganizeU128.pattern
}


use std/flow/void::Trigger as VoidTrigger
use std/conversion/scalar/u128::ToVoid

/**
Trigger on `u128` stream start and finish.

Send `start` when a first value is send through the stream.
Send `finish` when stream is finally over.

```mermaid
graph LR
    T(Trigger)
    B["ğŸ”´Â â€¦ ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â â€¦Â ğŸŸ¢"] -->|value| T
    
    T -->|start| S["ã€ˆğŸŸ©ã€‰"]
    T -->|finish| F["ã€ˆğŸŸ¥ã€‰"]

    style B fill:#ffff,stroke:#ffff
    style S fill:#ffff,stroke:#ffff
    style F fill:#ffff,stroke:#ffff
```

â„¹ï¸ If the stream never receive any data before being closed, only `finish` will be emitted.
*/
sequence Trigger()
  input  value:  Stream<u128>
  output start:  Block<void>
  output finish: Block<void>
{
    ToVoid()
    VoidTrigger()

    Self.value -> ToVoid.value,iter -> VoidTrigger.iter
    VoidTrigger.start --> Self.start
    VoidTrigger.finish -> Self.finish
}


use std/flow/void::VecTrigger as VoidVecTrigger
use std/conversion/vector/u128::ToVoid as ToVecVoid

/**
Trigger on `Vec<u128>` stream start and finish.

Send `start` when a first vector is send through the stream.
Send `finish` when stream is finally over.

```mermaid
graph LR
    T(VecTrigger)
    B["ğŸ”´Â â€¦ï¼»ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦ï¼½ï¼»ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦ï¼½ï¼»ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦ï¼½ï¼»ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦ï¼½Â â€¦Â ğŸŸ¢"] -->|value| T
    
    T -->|start| S["ã€ˆğŸŸ©ã€‰"]
    T -->|finish| F["ã€ˆğŸŸ¥ã€‰"]

    style B fill:#ffff,stroke:#ffff
    style S fill:#ffff,stroke:#ffff
    style F fill:#ffff,stroke:#ffff
```

â„¹ï¸ If the stream never receive any vector before being closed, only `finish` will be emitted.
*/
sequence VecTrigger()
  input  value:  Stream<Vec<u128>>
  output start:  Block<void>
  output finish: Block<void>
{
    ToVecVoid()
    VoidVecTrigger()

    Self.value -> ToVecVoid.vector,pattern -> VoidVecTrigger.iter
    VoidVecTrigger.start --> Self.start
    VoidVecTrigger.finish -> Self.finish
}


use std/flow/void::Count as VoidCount

/**
Gives count of elements passing through input stream.

This count increment one for each elements within the `value` stream, starting at 1.

```mermaid
graph LR
    T("Count()")
    V["ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â â€¦"] -->|value| T
    
    T -->|count| P["1ï¸âƒ£Â 2ï¸âƒ£Â 3ï¸âƒ£Â â€¦"]

    style V fill:#ffff,stroke:#ffff
    style P fill:#ffff,stroke:#ffff
```
*/
sequence Count()
  input  value: Stream<u128>
  output count: Stream<u128>
{
    ToVoid()
    VoidCount()

    Self.value ->  ToVoid.value,iter -> VoidCount.iter,count -> Self.count
}


use std/flow/void::VecCount as VoidVecCount

/**
Gives count of elements passing through input stream.

This count increment one for each elements within the `value` stream, starting at 1.

â„¹ï¸ This does not count the number of elements present in each vector, see the `Size` sequence instead.

```mermaid
graph LR
    T("VecCount()")
    V["ï¼»ğŸŸ¦Â ğŸŸ¦ï¼½ï¼»ğŸŸ¦ï¼½ï¼»ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦ï¼½â€¦"] -->|value| T
    
    T -->|count| P["1ï¸âƒ£Â 2ï¸âƒ£Â 3ï¸âƒ£Â â€¦"]

    style V fill:#ffff,stroke:#ffff
    style P fill:#ffff,stroke:#ffff
```
*/
sequence VecCount()
  input  value: Stream<Vec<u128>>
  output count: Stream<u128>
{
    ToVecVoid()
    VoidVecCount()

    Self.value -> ToVecVoid.vector,pattern -> VoidVecCount.iter,count -> Self.count
}


use std/flow/void::Size as VoidSize

/**
Gives number of elements present in each vector passing through input stream.

For each vector one `size` value is sent, giving the number of elements contained within matching vector.

```mermaid
graph LR
    T("Size()")
    V["â€¦ï¼»ğŸŸ¦Â ğŸŸ¦ï¼½ï¼»ğŸŸ¦ï¼½ï¼»ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦ï¼½â€¦"] -->|value| T
    
    T -->|size| P["â€¦Â 2ï¸âƒ£Â 1ï¸âƒ£Â 3ï¸âƒ£Â â€¦"]

    style V fill:#ffff,stroke:#ffff
    style P fill:#ffff,stroke:#ffff
```
*/
sequence Size()
  input  value: Stream<Vec<u128>>
  output size:  Stream<u64>
{
    ToVecVoid()
    VoidSize()

    Self.value -> ToVecVoid.vector,pattern -> VoidSize.pattern,size -> Self.size
}


use std/flow/void::Fit as VoidFit

/**
Creates stream of vectors based on requested sizes.

For each `size` received, a vector with the same number of values is sent through `pattern`.

```mermaid
graph LR
    T("Fit()")
    V["â€¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦Â â€¦"] -->|value| T
    S["â€¦Â 2ï¸âƒ£Â 1ï¸âƒ£Â 3ï¸âƒ£Â â€¦"] -->|size| T
    
    T -->|value| P["â€¦ï¼»ğŸŸ¦Â ğŸŸ¦ï¼½ï¼»ğŸŸ¦ï¼½ï¼»ğŸŸ¦Â ğŸŸ¦Â ğŸŸ¦ï¼½â€¦"]

    style V fill:#ffff,stroke:#ffff
    style S fill:#ffff,stroke:#ffff
    style P fill:#ffff,stroke:#ffff
```
*/
sequence Fit()
  input  value: Stream<u128>
  input  size:  Stream<u64>
  output value: Stream<Vec<u128>>
{
    VoidFit()
    Organize()

    Self.size -> VoidFit.size,pattern -> Organize.pattern
    Self.value ------------------------> Organize.value,values -> Self.value
}

