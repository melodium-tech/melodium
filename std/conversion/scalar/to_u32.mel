
use core/cast/scalar::U8ToU32 as CoreU8ToU32

/**
Convert stream of `u8` into `u32`.

This conversion is lossless, `u8` values can always fit into `u32` ones.
*/
sequence U8ToU32()
  input  value: Stream<u8>
  output value: Stream<u32>
{
    CoreU8ToU32()

    Self.value -> CoreU8ToU32.value,value -> Self.value
}



use core/cast/scalar::U16ToU32 as CoreU16ToU32

/**
Convert stream of `u16` into `u32`.

This conversion is lossless, `u16` values can always fit into `u32` ones.
*/
sequence U16ToU32()
  input  value: Stream<u16>
  output value: Stream<u32>
{
    CoreU16ToU32()

    Self.value -> CoreU16ToU32.value,value -> Self.value
}



use core/cast/scalar::CastScalarU64ToU32 as CoreCastScalarU64ToU32 

/**
Convert stream of `u64` into `u32`.

As this conversion might be lossy (every possible `u64` value cannot fit into `u32`),
`truncate` allows value to be truncated to fit into a `u32`, and `or_default` set the
value that is assigned when a `u64` is out of range for `u32` and truncation not allowed.
*/
sequence U64ToU32(var truncate: bool = true, var or_default: u32 = 0)
  input  value: Stream<u64>
  output value: Stream<u32>
{
    CoreCastScalarU64ToU32()

    Self.value -> CoreCastScalarU64ToU32.value,value -> Self.value
}



use core/cast/scalar::CastScalarU128ToU32 as CoreCastScalarU128ToU32 

/**
Convert stream of `u128` into `u32`.

As this conversion might be lossy (every possible `u128` value cannot fit into `u32`),
`truncate` allows value to be truncated to fit into a `u32`, and `or_default` set the
value that is assigned when a `u128` is out of range for `u32` and truncation not allowed.
*/
sequence U128ToU32(var truncate: bool = true, var or_default: u32 = 0)
  input  value: Stream<u128>
  output value: Stream<u32>
{
    CoreCastScalarU128ToU32()

    Self.value -> CoreCastScalarU128ToU32.value,value -> Self.value
}



use core/cast/scalar::CastScalarI8ToU32 as CoreCastScalarI8ToU32 

/**
Convert stream of `i8` into `u32`.

As this conversion might be lossy (every possible `i8` value cannot fit into `u32`),
`truncate` allows value to be truncated to fit into a `u32`, and `or_default` set the
value that is assigned when a `i8` is out of range for `u32` and truncation not allowed.
*/
sequence I8ToU32(var truncate: bool = true, var or_default: u32 = 0)
  input  value: Stream<i8>
  output value: Stream<u32>
{
    CoreCastScalarI8ToU32()

    Self.value -> CoreCastScalarI8ToU32.value,value -> Self.value
}



use core/cast/scalar::CastScalarI16ToU32 as CoreCastScalarI16ToU32 

/**
Convert stream of `i16` into `u32`.

As this conversion might be lossy (every possible `i16` value cannot fit into `u32`),
`truncate` allows value to be truncated to fit into a `u32`, and `or_default` set the
value that is assigned when a `i16` is out of range for `u32` and truncation not allowed.
*/
sequence I16ToU32(var truncate: bool = true, var or_default: u32 = 0)
  input  value: Stream<i16>
  output value: Stream<u32>
{
    CoreCastScalarI16ToU32()

    Self.value -> CoreCastScalarI16ToU32.value,value -> Self.value
}



use core/cast/scalar::CastScalarI32ToU32 as CoreCastScalarI32ToU32 

/**
Convert stream of `i32` into `u32`.

As this conversion might be lossy (every possible `i32` value cannot fit into `u32`),
`truncate` allows value to be truncated to fit into a `u32`, and `or_default` set the
value that is assigned when a `i32` is out of range for `u32` and truncation not allowed.
*/
sequence I32ToU32(var truncate: bool = true, var or_default: u32 = 0)
  input  value: Stream<i32>
  output value: Stream<u32>
{
    CoreCastScalarI32ToU32()

    Self.value -> CoreCastScalarI32ToU32.value,value -> Self.value
}



use core/cast/scalar::CastScalarI64ToU32 as CoreCastScalarI64ToU32 

/**
Convert stream of `i64` into `u32`.

As this conversion might be lossy (every possible `i64` value cannot fit into `u32`),
`truncate` allows value to be truncated to fit into a `u32`, and `or_default` set the
value that is assigned when a `i64` is out of range for `u32` and truncation not allowed.
*/
sequence I64ToU32(var truncate: bool = true, var or_default: u32 = 0)
  input  value: Stream<i64>
  output value: Stream<u32>
{
    CoreCastScalarI64ToU32()

    Self.value -> CoreCastScalarI64ToU32.value,value -> Self.value
}



use core/cast/scalar::CastScalarI128ToU32 as CoreCastScalarI128ToU32 

/**
Convert stream of `i128` into `u32`.

As this conversion might be lossy (every possible `i128` value cannot fit into `u32`),
`truncate` allows value to be truncated to fit into a `u32`, and `or_default` set the
value that is assigned when a `i128` is out of range for `u32` and truncation not allowed.
*/
sequence I128ToU32(var truncate: bool = true, var or_default: u32 = 0)
  input  value: Stream<i128>
  output value: Stream<u32>
{
    CoreCastScalarI128ToU32()

    Self.value -> CoreCastScalarI128ToU32.value,value -> Self.value
}



use core/conversion/scalar::ScalarF32ToU32 as CoreScalarF32ToU32 

/**
Convert stream of `f32` into `u32`.

Every `f32` is truncated to fit into the `u32`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f32` is a positive infinity,
- `neg_infinity` is used when `f32` is a negative infinity,
- `nan` is used when `f32` is not a number.
*/
sequence F32ToU32(var pos_infinity: u32 = 4294967295, var neg_infinity: u32 = 0, var nan: u32 = 0)
  input  value: Stream<f32>
  output value: Stream<u32>
{
    CoreScalarF32ToU32(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)

    Self.value -> CoreScalarF32ToU32.value,value -> Self.value
}



use core/conversion/scalar::ScalarF64ToU32 as CoreScalarF64ToU32 

/**
Convert stream of `f64` into `u32`.

Every `f64` is truncated to fit into the `u32`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f64` is a positive infinity,
- `neg_infinity` is used when `f64` is a negative infinity,
- `nan` is used when `f64` is not a number.
*/
sequence F64ToU32(var pos_infinity: u32 = 4294967295, var neg_infinity: u32 = 0, var nan: u32 = 0)
  input  value: Stream<f64>
  output value: Stream<u32>
{
    CoreScalarF64ToU32(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)

    Self.value -> CoreScalarF64ToU32.value,value -> Self.value
}


