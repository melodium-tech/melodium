use core/arithmetic/scalar::SqrtF32 

/**
Computes the square roots from a stream of `f32`.

*/
sequence Sqrt()
  input  value: Stream<f32>
  output value: Stream<f32>
{
    SqrtF32()

    Self.value -> SqrtF32.value,value -> Self.value
}


use core/arithmetic/scalar::CbrtF32 

/**
Computes the cube roots from a stream of `f32`.

*/
sequence Cbrt()
  input  value: Stream<f32>
  output value: Stream<f32>
{
    CbrtF32()

    Self.value -> CbrtF32.value,value -> Self.value
}


use core/arithmetic/scalar::LnF32 

/**
Computes the natural logarithms of a stream of `f32`.

*/
sequence Ln()
  input  value: Stream<f32>
  output value: Stream<f32>
{
    LnF32()

    Self.value -> LnF32.value,value -> Self.value
}

use core/arithmetic/scalar::StaticLogF32 

/**
Computes the logarithms from a stream of `f32` with respect to a static base.

*/
sequence StaticLog(var base: f32 = 10)
  input  value: Stream<f32>
  output value: Stream<f32>
{
    StaticLogF32(base=base)

    Self.value -> StaticLogF32.value,value -> Self.value
}


use core/arithmetic/scalar::LogF32 

/**
Computes logarithms from a stream of `f32` with the base of another one.

*/
sequence Log()
  input  value: Stream<f32>
  input  base:  Stream<f32>
  output log:   Stream<f32>
{
    LogF32()

    Self.base --> LogF32.base
    Self.value -> LogF32.value
    
    LogF32.log -> Self.log
}
use core/arithmetic/scalar::StaticAddF32

/**
Add a static value to `f32`.

Every number passed through the stream get `value` added.
*/
sequence StaticAdd(var value: f32 = 0)
  input  value: Stream<f32>
  output value: Stream<f32>
{
    StaticAddF32(value=value)

    Self.value -> StaticAddF32.value,value -> Self.value
}

use core/arithmetic/scalar::AddF32

/**
Add values from two streams of `f32`.

Values passed through a & b are added and send in sum.

*/
sequence Add()
  input  a:   Stream<f32>
  input  b:   Stream<f32>
  output sum: Stream<f32>
{
    AddF32()

    Self.a -> AddF32.a
    Self.b -> AddF32.b
    
    AddF32.sum -> Self.sum
}

use core/arithmetic/scalar::StaticSubF32 

/**
Substract a static value to `f32`.

Every number passed through the stream get `value` substracted.

*/
sequence StaticSub(var sub: f32 = 0)
  input  value: Stream<f32>
  output value: Stream<f32>
{
    StaticSubF32(sub=sub)

    Self.value -> StaticSubF32.value,value -> Self.value
}


use core/arithmetic/scalar::SubF32 

/**
Substract values from two streams of `f32`.

Every `a` number passed through the stream get `b` substracted.

*/
sequence Sub()
  input  a:          Stream<f32>
  input  b:          Stream<f32>
  output difference: Stream<f32>
{
    SubF32()

    Self.a -> SubF32.a
    Self.b -> SubF32.b
    
    SubF32.difference -> Self.difference
}


use core/arithmetic/scalar::StaticMultF32 

/**
Multiply `f32` by static value.

Every number passed through the stream is multiplied by `value`.

*/
sequence StaticMult(var factor: f32 = 0)
  input  value: Stream<f32>
  output value: Stream<f32>
{
    StaticMultF32(factor=factor)

    Self.value -> StaticMultF32.value,value -> Self.value
}


use core/arithmetic/scalar::MultF32 

/**
Multiply values from two streams of `f32`.

Every `a` number passed through the stream is multiplied by `b`.

*/
sequence Mult()
  input  a:       Stream<f32>
  input  b:       Stream<f32>
  output product: Stream<f32>
{
    MultF32()

    Self.a -> MultF32.a
    Self.b -> MultF32.b
    
    MultF32.product -> Self.product
}


use core/arithmetic/scalar::StaticDivF32 

/**
Divide a stream of `f32` by a static value.

Every number passed through the stream is divided by `value`.

*/
sequence StaticDiv(var divisor: f32 = 0)
  input  value: Stream<f32>
  output value: Stream<f32>
{
    StaticDivF32(divisor=divisor)

    Self.value -> StaticDivF32.value,value -> Self.value
}


use core/arithmetic/scalar::DivF32 

/**
Divide values from two streams of `f32`.

Every `a` number passed through the stream is divided by `b`.

*/
sequence Div()
  input  a:        Stream<f32>
  input  b:        Stream<f32>
  output quotient: Stream<f32>
{
    DivF32()

    Self.a -> DivF32.a
    Self.b -> DivF32.b
    
    DivF32.quotient -> Self.quotient
}


use core/arithmetic/scalar::StaticRemF32 

/**
Give the remainder of a stream of `f32` divided by a static value.

Every number passed through the stream is divided by `value` and the remainder is outputted.

*/
sequence StaticRem(var divisor: f32 = 0)
  input  value: Stream<f32>
  output value: Stream<f32>
{
    StaticRemF32(divisor=divisor)

    Self.value -> StaticRemF32.value,value -> Self.value
}


use core/arithmetic/scalar::RemF32 

/**
Give the remainder of the division from two streams of `f32`.

Every `a` number passed through the stream is divided by `b` and the remainder is outputted.

*/
sequence Rem()
  input  a:         Stream<f32>
  input  b:         Stream<f32>
  output remainder: Stream<f32>
{
    RemF32()

    Self.a -> RemF32.a
    Self.b -> RemF32.b
    
    RemF32.remainder -> Self.remainder
}




use core/arithmetic/scalar::StaticPowF32 

/**
Elevates `f32` to the power of a static value.

Every number passed through the stream get elevated to the power of `exponent`.
*/
sequence StaticPow(var exponent: f32 = 0)
  input  value: Stream<f32>
  output value: Stream<f32>
{
    StaticPowF32(exponent=exponent)

    Self.value -> StaticPowF32.value,value -> Self.value
}


use core/arithmetic/scalar::PowF32 

/**
Elevates values from a stream of `f32` to the power of another one.

Values passed through `base` are elevated to the power of `exponent`.

*/
sequence Pow()
  input  base:     Stream<f32>
  input  exponent: Stream<f32>
  output power:    Stream<f32>
{
    PowF32()

    Self.base -----> PowF32.base
    Self.exponent -> PowF32.exponent
    
    PowF32.power -> Self.power
}

use core/arithmetic/scalar::AbsF32

/**
Get the absolute values from a stream of `f32`.

*/
sequence Abs()
  input  value: Stream<f32>
  output value: Stream<f32>
{
    AbsF32()

    Self.value -> AbsF32.value,value -> Self.value
}
