
use core/cast/scalar::U8ToU16 as CoreU8ToU16

/**
Convert stream of `u8` into `u16`.

This conversion is lossless, `u8` values can always fit into `u16` ones.
*/
sequence U8ToU16()
  input  value: Stream<u8>
  output value: Stream<u16>
{
    CoreU8ToU16()

    Self.value -> CoreU8ToU16.value,value -> Self.value
}



use core/cast/scalar::CastScalarU32ToU16 as CoreCastScalarU32ToU16 

/**
Convert stream of `u32` into `u16`.

As this conversion might be lossy (every possible `u32` value cannot fit into `u16`),
`truncate` allows value to be truncated to fit into a `u16`, and `or_default` set the
value that is assigned when a `u32` is out of range for `u16` and truncation not allowed.
*/
sequence U32ToU16(var truncate: bool = true, var or_default: u16 = 0)
  input  value: Stream<u32>
  output value: Stream<u16>
{
    CoreCastScalarU32ToU16()

    Self.value -> CoreCastScalarU32ToU16.value,value -> Self.value
}



use core/cast/scalar::CastScalarU64ToU16 as CoreCastScalarU64ToU16 

/**
Convert stream of `u64` into `u16`.

As this conversion might be lossy (every possible `u64` value cannot fit into `u16`),
`truncate` allows value to be truncated to fit into a `u16`, and `or_default` set the
value that is assigned when a `u64` is out of range for `u16` and truncation not allowed.
*/
sequence U64ToU16(var truncate: bool = true, var or_default: u16 = 0)
  input  value: Stream<u64>
  output value: Stream<u16>
{
    CoreCastScalarU64ToU16()

    Self.value -> CoreCastScalarU64ToU16.value,value -> Self.value
}



use core/cast/scalar::CastScalarU128ToU16 as CoreCastScalarU128ToU16 

/**
Convert stream of `u128` into `u16`.

As this conversion might be lossy (every possible `u128` value cannot fit into `u16`),
`truncate` allows value to be truncated to fit into a `u16`, and `or_default` set the
value that is assigned when a `u128` is out of range for `u16` and truncation not allowed.
*/
sequence U128ToU16(var truncate: bool = true, var or_default: u16 = 0)
  input  value: Stream<u128>
  output value: Stream<u16>
{
    CoreCastScalarU128ToU16()

    Self.value -> CoreCastScalarU128ToU16.value,value -> Self.value
}



use core/cast/scalar::CastScalarI8ToU16 as CoreCastScalarI8ToU16 

/**
Convert stream of `i8` into `u16`.

As this conversion might be lossy (every possible `i8` value cannot fit into `u16`),
`truncate` allows value to be truncated to fit into a `u16`, and `or_default` set the
value that is assigned when a `i8` is out of range for `u16` and truncation not allowed.
*/
sequence I8ToU16(var truncate: bool = true, var or_default: u16 = 0)
  input  value: Stream<i8>
  output value: Stream<u16>
{
    CoreCastScalarI8ToU16()

    Self.value -> CoreCastScalarI8ToU16.value,value -> Self.value
}



use core/cast/scalar::CastScalarI16ToU16 as CoreCastScalarI16ToU16 

/**
Convert stream of `i16` into `u16`.

As this conversion might be lossy (every possible `i16` value cannot fit into `u16`),
`truncate` allows value to be truncated to fit into a `u16`, and `or_default` set the
value that is assigned when a `i16` is out of range for `u16` and truncation not allowed.
*/
sequence I16ToU16(var truncate: bool = true, var or_default: u16 = 0)
  input  value: Stream<i16>
  output value: Stream<u16>
{
    CoreCastScalarI16ToU16()

    Self.value -> CoreCastScalarI16ToU16.value,value -> Self.value
}



use core/cast/scalar::CastScalarI32ToU16 as CoreCastScalarI32ToU16 

/**
Convert stream of `i32` into `u16`.

As this conversion might be lossy (every possible `i32` value cannot fit into `u16`),
`truncate` allows value to be truncated to fit into a `u16`, and `or_default` set the
value that is assigned when a `i32` is out of range for `u16` and truncation not allowed.
*/
sequence I32ToU16(var truncate: bool = true, var or_default: u16 = 0)
  input  value: Stream<i32>
  output value: Stream<u16>
{
    CoreCastScalarI32ToU16()

    Self.value -> CoreCastScalarI32ToU16.value,value -> Self.value
}



use core/cast/scalar::CastScalarI64ToU16 as CoreCastScalarI64ToU16 

/**
Convert stream of `i64` into `u16`.

As this conversion might be lossy (every possible `i64` value cannot fit into `u16`),
`truncate` allows value to be truncated to fit into a `u16`, and `or_default` set the
value that is assigned when a `i64` is out of range for `u16` and truncation not allowed.
*/
sequence I64ToU16(var truncate: bool = true, var or_default: u16 = 0)
  input  value: Stream<i64>
  output value: Stream<u16>
{
    CoreCastScalarI64ToU16()

    Self.value -> CoreCastScalarI64ToU16.value,value -> Self.value
}



use core/cast/scalar::CastScalarI128ToU16 as CoreCastScalarI128ToU16 

/**
Convert stream of `i128` into `u16`.

As this conversion might be lossy (every possible `i128` value cannot fit into `u16`),
`truncate` allows value to be truncated to fit into a `u16`, and `or_default` set the
value that is assigned when a `i128` is out of range for `u16` and truncation not allowed.
*/
sequence I128ToU16(var truncate: bool = true, var or_default: u16 = 0)
  input  value: Stream<i128>
  output value: Stream<u16>
{
    CoreCastScalarI128ToU16()

    Self.value -> CoreCastScalarI128ToU16.value,value -> Self.value
}



use core/conversion/scalar::ScalarF32ToU16 as CoreScalarF32ToU16 

/**
Convert stream of `f32` into `u16`.

Every `f32` is truncated to fit into the `u16`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f32` is a positive infinity,
- `neg_infinity` is used when `f32` is a negative infinity,
- `nan` is used when `f32` is not a number.
*/
sequence F32ToU16(var pos_infinity: u16 = 65535, var neg_infinity: u16 = 0, var nan: u16 = 0)
  input  value: Stream<f32>
  output value: Stream<u16>
{
    CoreScalarF32ToU16(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)

    Self.value -> CoreScalarF32ToU16.value,value -> Self.value
}



use core/conversion/scalar::ScalarF64ToU16 as CoreScalarF64ToU16 

/**
Convert stream of `f64` into `u16`.

Every `f64` is truncated to fit into the `u16`, and in case floating-point value does
not describe a real number:
- `pos_infinity` is used when `f64` is a positive infinity,
- `neg_infinity` is used when `f64` is a negative infinity,
- `nan` is used when `f64` is not a number.
*/
sequence F64ToU16(var pos_infinity: u16 = 65535, var neg_infinity: u16 = 0, var nan: u16 = 0)
  input  value: Stream<f64>
  output value: Stream<u16>
{
    CoreScalarF64ToU16(pos_infinity=pos_infinity, neg_infinity=neg_infinity, nan=nan)

    Self.value -> CoreScalarF64ToU16.value,value -> Self.value
}


